<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InjectedAppImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.app.di</a> &gt; <span class="el_source">InjectedAppImpl.java</span></div><h1>InjectedAppImpl.java</h1><pre class="source lang-java linenums">package space.sunqian.common.app.di;

import space.sunqian.annotations.Immutable;
import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.annotations.OutParam;
import space.sunqian.common.Fs;
import space.sunqian.common.collect.ArrayKit;
import space.sunqian.common.collect.ListKit;
import space.sunqian.common.dynamic.aspect.AspectMaker;
import space.sunqian.common.dynamic.aspect.AspectSpec;
import space.sunqian.common.invoke.Invocable;
import space.sunqian.common.invoke.InvocationException;
import space.sunqian.common.reflect.TypeKit;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

final class InjectedAppImpl implements InjectedApp {

    private final @Nonnull Map&lt;@Nonnull Type, @Nonnull InjectedResource&gt; resources;
    private final @Nonnull Map&lt;@Nonnull Type, @Nonnull InjectedResource&gt; localResources;
    private final @Nonnull List&lt;@Nonnull InjectedResource&gt; preDestroyList;
    private final @Nonnull List&lt;@Nonnull InjectedApp&gt; parentApps;

    public InjectedAppImpl(
        @Nonnull Collection&lt;@Nonnull Type&gt; resourceTypes,
        @Nonnull Collection&lt;@Nonnull InjectedApp&gt; parentApps,
        @Nonnull Collection&lt;@Nonnull String&gt; resourceAnnotations,
        @Nonnull Collection&lt;@Nonnull String&gt; postConstructAnnotations,
        @Nonnull Collection&lt;@Nonnull String&gt; preDestroyAnnotations,
        @Nonnull InjectedResource.Resolver resolver,
        @Nonnull InjectedResource.FieldSetter fieldSetter
<span class="fc" id="L49">    ) throws InjectedResourceInitializationException, InjectedAppException {</span>
<span class="fc" id="L50">        Map&lt;Type, Res&gt; resourceMap = new LinkedHashMap&lt;&gt;();</span>
        // add parent resource into this app
<span class="fc bfc" id="L52" title="All 2 branches covered.">        for (InjectedApp parentApp : parentApps) {</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">            for (InjectedResource resource : parentApp.resources().values()) {</span>
<span class="fc" id="L54">                resourceMap.put(resource.type(), new Res(resource.type(), resource.instance()));</span>
<span class="fc" id="L55">            }</span>
<span class="fc" id="L56">        }</span>
<span class="fc" id="L57">        Set&lt;FieldRes&gt; fieldSet = new LinkedHashSet&lt;&gt;();</span>
        // generate instances
<span class="fc bfc" id="L59" title="All 2 branches covered.">        for (Type resourceType : resourceTypes) {</span>
<span class="fc" id="L60">            doDependencyInjection(</span>
                resourceType,
                resourceAnnotations,
                postConstructAnnotations,
                preDestroyAnnotations,
                resolver,
                resourceMap,
                fieldSet
            );
<span class="fc" id="L69">        }</span>
        // base injects:
<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (FieldRes fieldRes : fieldSet) {</span>
<span class="fc" id="L72">            setField(</span>
                fieldSetter,
<span class="fc" id="L74">                fieldRes.field,</span>
<span class="fc" id="L75">                fieldRes.owner.instance,</span>
<span class="fc" id="L76">                getRes(fieldRes.field.getGenericType(), resourceMap).instance</span>
            );
<span class="fc" id="L78">        }</span>
        // aop
<span class="fc" id="L80">        doAop(fieldSetter, resourceMap, fieldSet);</span>
        // resources
<span class="fc" id="L82">        LinkedHashMap&lt;Type, InjectedResource&gt; resources = new LinkedHashMap&lt;&gt;(resourceMap.size());</span>
<span class="fc" id="L83">        LinkedHashMap&lt;Type, InjectedResource&gt; localResources = new LinkedHashMap&lt;&gt;(resourceMap.size());</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        for (Res res : resourceMap.values()) {</span>
<span class="fc" id="L85">            Object inst = getResInstance(res);</span>
<span class="fc" id="L86">            InjectedResource simpleResource = new InjectedRes(</span>
<span class="fc" id="L87">                res.type,</span>
                inst,
<span class="fc" id="L89">                res.local,</span>
<span class="fc" id="L90">                res.postConstructMethod(),</span>
<span class="fc" id="L91">                res.preDestroyMethod()</span>
            );
<span class="fc" id="L93">            resources.put(res.type, simpleResource);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">            if (res.local) {</span>
<span class="fc" id="L95">                localResources.put(res.type, simpleResource);</span>
            }
<span class="fc" id="L97">        }</span>
<span class="fc" id="L98">        this.parentApps = ListKit.toList(parentApps);</span>
<span class="fc" id="L99">        this.resources = Collections.unmodifiableMap(resources);</span>
<span class="fc" id="L100">        this.localResources = Collections.unmodifiableMap(localResources);</span>
        // post-construct and pre-destroy
<span class="fc" id="L102">        Set&lt;InjectedResource&gt; postConstructSet = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L103">        Set&lt;InjectedResource&gt; preDestroySet = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L104">        Set&lt;Type&gt; stack = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (InjectedResource resource : localResources.values()) {</span>
<span class="fc" id="L106">            checkDependencyForPostConstruct(resource, stack, postConstructSet);</span>
<span class="fc" id="L107">            stack.clear();</span>
<span class="fc" id="L108">            checkDependencyForPreDestroy(resource, stack, preDestroySet);</span>
<span class="fc" id="L109">            stack.clear();</span>
<span class="fc" id="L110">        }</span>
<span class="fc" id="L111">        List&lt;InjectedResource&gt; postConstructList = new ArrayList&lt;&gt;(postConstructSet);</span>
<span class="fc" id="L112">        postConstructList.sort(PostConstructComparator.INST);</span>
<span class="fc" id="L113">        List&lt;InjectedResource&gt; preDestroyList = new ArrayList&lt;&gt;(preDestroySet);</span>
<span class="fc" id="L114">        preDestroyList.sort(PreDestroyComparator.INST);</span>
<span class="fc" id="L115">        this.preDestroyList = preDestroyList;</span>
        // execute post-construct
<span class="fc" id="L117">        doPostConstruct(postConstructList);</span>
<span class="fc" id="L118">    }</span>

    private void doPostConstruct(@Nonnull List&lt;@Nonnull InjectedResource&gt; postConstructList) {
        // execute post-construct
<span class="fc" id="L122">        List&lt;InjectedResource&gt; uninitializedResources = new ArrayList&lt;&gt;(postConstructList);</span>
<span class="fc" id="L123">        List&lt;InjectedResource&gt; initializedResources = new ArrayList&lt;&gt;(postConstructList.size());</span>
<span class="fc" id="L124">        Iterator&lt;InjectedResource&gt; uninitializedIt = uninitializedResources.iterator();</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        while (uninitializedIt.hasNext()) {</span>
<span class="fc" id="L126">            InjectedResource resource = uninitializedIt.next();</span>
            try {
<span class="fc" id="L128">                resource.postConstruct();</span>
<span class="fc" id="L129">            } catch (Exception e) {</span>
<span class="fc" id="L130">                throw new InjectedResourceInitializationException(resource, e, initializedResources, uninitializedResources);</span>
            } finally {
<span class="fc" id="L132">                uninitializedIt.remove();</span>
            }
<span class="fc" id="L134">            initializedResources.add(resource);</span>
<span class="fc" id="L135">        }</span>
<span class="fc" id="L136">    }</span>

    private void doDependencyInjection(
        @Nonnull Type type,
        @Nonnull Collection&lt;@Nonnull String&gt; resourceAnnotations,
        @Nonnull Collection&lt;@Nonnull String&gt; postConstructAnnotations,
        @Nonnull Collection&lt;@Nonnull String&gt; preDestroyAnnotations,
        @Nonnull InjectedResource.Resolver resolver,
        @Nonnull @OutParam Map&lt;@Nonnull Type, @Nonnull Res&gt; resourceMap,
        @Nonnull @OutParam Set&lt;@Nonnull FieldRes&gt; fieldSet
    ) throws InjectedAppException {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (resourceMap.containsKey(type)) {</span>
<span class="fc" id="L148">            return;</span>
        }
<span class="fc" id="L150">        InjectedResource.Descriptor descriptor = Fs.uncheck(() -&gt;</span>
<span class="fc" id="L151">                resolver.resolve(type, resourceAnnotations, postConstructAnnotations, preDestroyAnnotations),</span>
            InjectedAppException::new
        );
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (!canInstantiate(descriptor.rawClass())) {</span>
<span class="fc" id="L155">            return;</span>
        }
<span class="fc" id="L157">        Res res = new Res(descriptor);</span>
<span class="fc" id="L158">        resourceMap.put(type, res);</span>
        // dependency fields
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (Field dependencyField : descriptor.dependencyFields()) {</span>
<span class="fc" id="L161">            Type dependencyType = dependencyField.getGenericType();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (dependencyType.equals(type)) {</span>
<span class="fc" id="L163">                fieldSet.add(new FieldRes(dependencyField, res));</span>
<span class="fc" id="L164">                continue;</span>
            }
<span class="fc" id="L166">            doDependencyInjection(</span>
                dependencyType,
                resourceAnnotations,
                postConstructAnnotations,
                preDestroyAnnotations,
                resolver,
                resourceMap,
                fieldSet
            );
<span class="fc" id="L175">            fieldSet.add(new FieldRes(dependencyField, res));</span>
<span class="fc" id="L176">        }</span>
        // dependency parameters of post-construct method
<span class="fc" id="L178">        Method postConstructMethod = descriptor.postConstructMethod();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (postConstructMethod != null) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">            for (Type parameterType : postConstructMethod.getGenericParameterTypes()) {</span>
<span class="fc" id="L181">                doDependencyInjection(</span>
                    parameterType,
                    resourceAnnotations,
                    postConstructAnnotations,
                    preDestroyAnnotations,
                    resolver,
                    resourceMap,
                    fieldSet
                );
            }
        }
        // dependency parameters of pre-destroy method
<span class="fc" id="L193">        Method preDestroyMethod = descriptor.preDestroyMethod();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (preDestroyMethod != null) {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            for (Type parameterType : preDestroyMethod.getGenericParameterTypes()) {</span>
<span class="fc" id="L196">                doDependencyInjection(</span>
                    parameterType,
                    resourceAnnotations,
                    postConstructAnnotations,
                    preDestroyAnnotations,
                    resolver,
                    resourceMap,
                    fieldSet
                );
            }
        }
<span class="fc" id="L207">    }</span>

    private boolean canInstantiate(@Nonnull Class&lt;?&gt; type) {
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (type.isInterface()) {</span>
<span class="fc" id="L211">            return false;</span>
        }
<span class="fc bfc" id="L213" title="All 2 branches covered.">        return !Modifier.isAbstract(type.getModifiers());</span>
    }

    private void doAop(
        @Nonnull InjectedResource.FieldSetter fieldSetter,
        @Nonnull @OutParam Map&lt;@Nonnull Type, @Nonnull Res&gt; resourceMap,
        @Nonnull @OutParam Set&lt;@Nonnull FieldRes&gt; fieldSet
    ) throws InjectedAppException {
<span class="fc" id="L221">        List&lt;InjectedAspect&gt; aspects = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (Res res : resourceMap.values()) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (!res.local) {</span>
<span class="fc" id="L224">                continue;</span>
            }
<span class="fc" id="L226">            Object instance = res.instance;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (instance instanceof InjectedAspect) {</span>
<span class="fc" id="L228">                aspects.add((InjectedAspect) instance);</span>
<span class="fc" id="L229">                res.isAspectHandler = true;</span>
            }
<span class="fc" id="L231">        }</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (aspects.isEmpty()) {</span>
<span class="fc" id="L233">            return;</span>
        }
<span class="fc" id="L235">        AspectMaker aspectMaker = AspectMaker.byAsm();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (Res res : resourceMap.values()) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (!res.local) {</span>
<span class="fc" id="L238">                continue;</span>
            }
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (res.isAspectHandler) {</span>
<span class="fc" id="L241">                continue;</span>
            }
<span class="fc bfc" id="L243" title="All 2 branches covered.">            for (InjectedAspect aspect : aspects) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">                if (aspect.needsAspect(res.type)) {</span>
<span class="fc" id="L245">                    AspectSpec spec = aspectMaker.make(Fs.asNonnull(res.descriptor).rawClass(), aspect);</span>
<span class="fc" id="L246">                    res.advisedInstance = spec.newInstance();</span>
<span class="fc" id="L247">                    break;</span>
                }
<span class="fc" id="L249">            }</span>
<span class="fc" id="L250">        }</span>
        // rewrite fields
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (FieldRes fieldRes : fieldSet) {</span>
<span class="fc" id="L253">            boolean needsRewrite = false;</span>
            Object owner;
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (fieldRes.owner.advisedInstance != null) {</span>
<span class="fc" id="L256">                needsRewrite = true;</span>
<span class="fc" id="L257">                owner = fieldRes.owner.advisedInstance;</span>
            } else {
<span class="fc" id="L259">                owner = fieldRes.owner.instance;</span>
            }
<span class="fc" id="L261">            Res valueRes = getRes(fieldRes.field.getGenericType(), resourceMap);</span>
            Object value;
<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (valueRes.advisedInstance != null) {</span>
<span class="fc" id="L264">                needsRewrite = true;</span>
<span class="fc" id="L265">                value = valueRes.advisedInstance;</span>
            } else {
<span class="fc" id="L267">                value = valueRes.instance;</span>
            }
<span class="fc bfc" id="L269" title="All 2 branches covered.">            if (needsRewrite) {</span>
<span class="fc" id="L270">                setField(fieldSetter, fieldRes.field, owner, value);</span>
            }
<span class="fc" id="L272">        }</span>
<span class="fc" id="L273">    }</span>

    private void setField(
        @Nonnull InjectedResource.FieldSetter fieldSetter,
        @Nonnull Field field, @Nonnull Object owner, @Nonnull Object value
    ) throws InjectedAppException {
<span class="fc" id="L279">        Fs.uncheck(</span>
            () -&gt; {
<span class="fc" id="L281">                fieldSetter.set(field, owner, value);</span>
<span class="fc" id="L282">            },</span>
            InjectedAppException::new
        );
<span class="fc" id="L285">    }</span>

    private @Nonnull Res getRes(
        @Nonnull Type type,
        @Nonnull Map&lt;@Nonnull Type, @Nonnull Res&gt; resourceMap
    ) throws InjectedAppException {
<span class="fc" id="L291">        Res res = resourceMap.get(type);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (res != null) {</span>
<span class="fc" id="L293">            return res;</span>
        }
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (Res resource : resourceMap.values()) {</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (TypeKit.isAssignable(type, resource.type)) {</span>
<span class="fc" id="L297">                return resource;</span>
            }
<span class="fc" id="L299">        }</span>
<span class="fc" id="L300">        throw new InjectedAppException(&quot;Can not find resource instance for type :&quot; + type.getTypeName() + &quot;.&quot;);</span>
    }

    private void checkDependencyForPostConstruct(
        @Nonnull InjectedResource curRes,
        @Nonnull Set&lt;@Nonnull Type&gt; stack,
        @Nonnull @OutParam Set&lt;@Nonnull InjectedResource&gt; postConstructSet
    ) throws InjectedAppException {
<span class="fc" id="L308">        Type curType = curRes.type();</span>
<span class="fc" id="L309">        Method postConstructMethod = curRes.postConstructMethod();</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (postConstructMethod == null) {</span>
<span class="fc" id="L311">            return;</span>
        }
<span class="fc" id="L313">        postConstructSet.add(curRes);</span>
<span class="fc" id="L314">        Type[] sdo = postConstructMethod.getGenericParameterTypes();</span>
        // InjectedDependsOn sdo = postConstructMethod.getAnnotation(InjectedDependsOn.class);
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (ArrayKit.isEmpty(sdo)) {</span>
<span class="fc" id="L317">            return;</span>
        }
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (!stack.add(curType)) {</span>
<span class="fc" id="L320">            throw new InjectedAppException(</span>
                &quot;Circular post-construct dependency detected: &quot; +
<span class="fc" id="L322">                    stack.stream().map(Type::getTypeName).collect(Collectors.joining(&quot; -&gt; &quot;)) + &quot;.&quot;</span>
            );
        }
<span class="fc bfc" id="L325" title="All 2 branches covered.">        for (Type depType : sdo) {</span>
<span class="fc" id="L326">            InjectedResource depRes = resources.get(depType);</span>
            // if (depRes == null) {
            //     throw new InjectedAppException(&quot;Unknown post-construct dependency type: &quot; + depType.getTypeName() + &quot;.&quot;);
            // }
<span class="fc" id="L330">            checkDependencyForPostConstruct(depRes, stack, postConstructSet);</span>
<span class="fc" id="L331">            stack.remove(depType);</span>
        }
<span class="fc" id="L333">    }</span>

    private void checkDependencyForPreDestroy(
        @Nonnull InjectedResource curRes,
        @Nonnull Set&lt;@Nonnull Type&gt; stack,
        @Nonnull @OutParam Set&lt;@Nonnull InjectedResource&gt; preDestroySet
    ) throws InjectedAppException {
<span class="fc" id="L340">        Type curType = curRes.type();</span>
<span class="fc" id="L341">        Method preDestroyMethod = curRes.preDestroyMethod();</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (preDestroyMethod == null) {</span>
<span class="fc" id="L343">            return;</span>
        }
<span class="fc" id="L345">        preDestroySet.add(curRes);</span>
<span class="fc" id="L346">        Type[] sdo = preDestroyMethod.getGenericParameterTypes();</span>
        // InjectedDependsOn sdo = preDestroyMethod.getAnnotation(InjectedDependsOn.class);
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (ArrayKit.isEmpty(sdo)) {</span>
<span class="fc" id="L349">            return;</span>
        }
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (!stack.add(curType)) {</span>
<span class="fc" id="L352">            throw new InjectedAppException(</span>
                &quot;Circular pre-destroy dependency: &quot; +
<span class="fc" id="L354">                    stack.stream().map(Type::getTypeName).collect(Collectors.joining(&quot; -&gt; &quot;)) + &quot;.&quot;</span>
            );
        }
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (Type depType : sdo) {</span>
<span class="fc" id="L358">            InjectedResource depRes = resources.get(depType);</span>
            // if (depRes == null) {
            //     throw new InjectedAppException(&quot;Unknown pre-destroy dependency type: &quot; + depType.getTypeName() + &quot;.&quot;);
            // }
<span class="fc" id="L362">            checkDependencyForPreDestroy(depRes, stack, preDestroySet);</span>
<span class="fc" id="L363">            stack.remove(depType);</span>
        }
<span class="fc" id="L365">    }</span>

    private @Nonnull Object getResInstance(
        @Nonnull Res res
    ) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">        return res.advisedInstance != null ? res.advisedInstance : res.instance;</span>
    }

    @Override
    public void shutdown() throws InjectedResourceDestructionException, InjectedAppException {
<span class="fc" id="L375">        List&lt;InjectedResource&gt; undestroyedResources = new ArrayList&lt;&gt;(preDestroyList);</span>
<span class="fc" id="L376">        List&lt;InjectedResource&gt; destroyedResources = new ArrayList&lt;&gt;(preDestroyList.size());</span>
<span class="fc" id="L377">        Iterator&lt;InjectedResource&gt; undestroyedIt = undestroyedResources.iterator();</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        while (undestroyedIt.hasNext()) {</span>
<span class="fc" id="L379">            InjectedResource resource = undestroyedIt.next();</span>
            try {
<span class="fc" id="L381">                resource.preDestroy();</span>
<span class="fc" id="L382">                destroyedResources.add(resource);</span>
<span class="fc" id="L383">            } catch (Exception e) {</span>
<span class="fc" id="L384">                throw new InjectedResourceDestructionException(resource, e, destroyedResources, undestroyedResources);</span>
            } finally {
<span class="fc" id="L386">                undestroyedIt.remove();</span>
            }
<span class="fc" id="L388">        }</span>
<span class="fc" id="L389">    }</span>

    @Override
    public @Nonnull List&lt;@Nonnull InjectedApp&gt; parentApps() {
<span class="fc" id="L393">        return parentApps;</span>
    }

    @Override
    public @Nonnull Map&lt;@Nonnull Type, @Nonnull InjectedResource&gt; localResources() {
<span class="fc" id="L398">        return localResources;</span>
    }

    @Override
    public @Nonnull Map&lt;@Nonnull Type, @Nonnull InjectedResource&gt; resources() {
<span class="fc" id="L403">        return resources;</span>
    }

    @Override
    public @Nullable InjectedResource getResource(@Nonnull Type type) {
<span class="fc" id="L408">        return resources.get(type);</span>
    }

    @Override
    public @Nullable Object getObject(@Nonnull Type type) {
<span class="fc" id="L413">        InjectedResource resource = resources.get(type);</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (resource != null) {</span>
<span class="fc" id="L415">            return resource.instance();</span>
        }
<span class="fc bfc" id="L417" title="All 2 branches covered.">        for (InjectedResource sr : resources.values()) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            if (TypeKit.isAssignable(type, sr.type())) {</span>
<span class="fc" id="L419">                return sr.instance();</span>
            }
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">        return null;</span>
    }

    private static @Nonnull Class&lt;?&gt; rawClass(@Nonnull Type type) {
<span class="fc" id="L426">        Class&lt;?&gt; raw = TypeKit.getRawClass(type);</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if (raw == null) {</span>
<span class="fc" id="L428">            throw new InjectedAppException(&quot;Unsupported DI type: &quot; + type.getTypeName() + &quot;.&quot;);</span>
        }
<span class="fc" id="L430">        return raw;</span>
    }

    private static final class Res {

        private final @Nonnull Type type;
        private final boolean local;
        private final @Nonnull Object instance;
        private final @Nullable InjectedResource.Descriptor descriptor;

        private Object advisedInstance;
<span class="fc" id="L441">        private boolean isAspectHandler = false;</span>

        private Res(
            @Nonnull InjectedResource.Descriptor descriptor
<span class="fc" id="L445">        ) throws InjectedAppException {</span>
<span class="fc" id="L446">            this.type = descriptor.type();</span>
<span class="fc" id="L447">            this.local = true;</span>
<span class="fc" id="L448">            this.descriptor = descriptor;</span>
            try {
<span class="fc" id="L450">                this.instance = Invocable.of(descriptor.rawClass().getConstructor()).invoke(null);</span>
<span class="fc" id="L451">            } catch (Exception e) {</span>
<span class="fc" id="L452">                throw new InjectedAppException(&quot;Creates instance for &quot; + type.getTypeName() + &quot; failed.&quot;, e);</span>
<span class="fc" id="L453">            }</span>
<span class="fc" id="L454">        }</span>

<span class="fc" id="L456">        private Res(@Nonnull Type type, @Nonnull Object instance) {</span>
<span class="fc" id="L457">            this.type = type;</span>
<span class="fc" id="L458">            this.local = false;</span>
<span class="fc" id="L459">            this.descriptor = null;</span>
<span class="fc" id="L460">            this.instance = instance;</span>
<span class="fc" id="L461">        }</span>

        public @Nullable Method postConstructMethod() {
<span class="fc bfc" id="L464" title="All 2 branches covered.">            return descriptor != null ? descriptor.postConstructMethod() : null;</span>
        }

        public @Nullable Method preDestroyMethod() {
<span class="fc bfc" id="L468" title="All 2 branches covered.">            return descriptor != null ? descriptor.preDestroyMethod() : null;</span>
        }
    }

    private static final class FieldRes {

        private final @Nonnull Field field;
        private final @Nonnull Res owner;

<span class="fc" id="L477">        private FieldRes(@Nonnull Field field, @Nonnull Res owner) {</span>
<span class="fc" id="L478">            this.field = field;</span>
<span class="fc" id="L479">            this.owner = owner;</span>
<span class="fc" id="L480">        }</span>
    }

    private final class InjectedRes implements InjectedResource {

        private final @Nonnull Type type;
        private final @Nonnull Object instance;
        private final boolean local;
        private final @Nullable Method postConstructMethod;
        private final @Nonnull Runnable postConstruct;
        private final @Nullable Method preDestroyMethod;
        private final @Nonnull Runnable preDestroy;
<span class="fc" id="L492">        private volatile int state = 0;</span>

        private InjectedRes(
            @Nonnull Type type,
            @Nonnull Object instance,
            boolean local,
            @Nullable Method postConstructMethod,
            @Nullable Method preDestroyMethod
<span class="fc" id="L500">        ) {</span>
<span class="fc" id="L501">            this.type = type;</span>
<span class="fc" id="L502">            this.instance = instance;</span>
<span class="fc" id="L503">            this.local = local;</span>
<span class="fc" id="L504">            this.postConstructMethod = postConstructMethod;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            this.postConstruct = postConstructMethod == null ?</span>
<span class="fc" id="L506">                () -&gt; {}</span>
                :
                () -&gt; {
<span class="fc" id="L509">                    Invocable invocable = Invocable.of(postConstructMethod);</span>
<span class="fc" id="L510">                    Type[] paramTypes = postConstructMethod.getGenericParameterTypes();</span>
<span class="fc" id="L511">                    Object[] args = new Object[paramTypes.length];</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">                    for (int i = 0; i &lt; paramTypes.length; i++) {</span>
<span class="fc" id="L513">                        args[i] = getObject(paramTypes[i]);</span>
                    }
<span class="fc" id="L515">                    invocable.invoke(instance, args);</span>
<span class="fc" id="L516">                };</span>

<span class="fc" id="L518">            this.preDestroyMethod = preDestroyMethod;</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            this.preDestroy = preDestroyMethod == null ?</span>
<span class="fc" id="L520">                () -&gt; {}</span>
                :
                () -&gt; {
<span class="fc" id="L523">                    Invocable invocable = Invocable.of(preDestroyMethod);</span>
<span class="fc" id="L524">                    Type[] paramTypes = preDestroyMethod.getGenericParameterTypes();</span>
<span class="fc" id="L525">                    Object[] args = new Object[paramTypes.length];</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                    for (int i = 0; i &lt; paramTypes.length; i++) {</span>
<span class="fc" id="L527">                        args[i] = getObject(paramTypes[i]);</span>
                    }
<span class="fc" id="L529">                    invocable.invoke(instance, args);</span>
<span class="fc" id="L530">                };</span>
<span class="fc" id="L531">        }</span>

        @Override
        public @Nonnull Type type() {
<span class="fc" id="L535">            return type;</span>
        }

        @Override
        public @Nonnull Object instance() {
<span class="fc" id="L540">            return instance;</span>
        }

        @Override
        public boolean isLocal() {
<span class="fc" id="L545">            return local;</span>
        }

        @Override
        public @Nullable Method postConstructMethod() {
<span class="fc" id="L550">            return postConstructMethod;</span>
        }

        @Override
        public void postConstruct() throws InvocationException {
<span class="fc" id="L555">            postConstruct.run();</span>
<span class="fc" id="L556">            state = 1;</span>
<span class="fc" id="L557">        }</span>

        @Override
        public boolean isInitialized() {
<span class="fc bfc" id="L561" title="All 2 branches covered.">            return state == 1;</span>
        }

        @Override
        public @Nullable Method preDestroyMethod() {
<span class="fc" id="L566">            return preDestroyMethod;</span>
        }

        @Override
        public void preDestroy() throws InvocationException {
<span class="fc" id="L571">            preDestroy.run();</span>
<span class="fc" id="L572">            state = 2;</span>
<span class="fc" id="L573">        }</span>

        @Override
        public boolean isDestroyed() {
<span class="fc bfc" id="L577" title="All 2 branches covered.">            return state == 2;</span>
        }
    }

<span class="fc" id="L581">    enum Resolver implements InjectedResource.Resolver {</span>

<span class="fc" id="L583">        INST;</span>

        @Override
        public InjectedResource.@Nonnull Descriptor resolve(
            @Nonnull Type type,
            @Nonnull Collection&lt;@Nonnull String&gt; resourceAnnotations,
            @Nonnull Collection&lt;@Nonnull String&gt; postConstructAnnotations,
            @Nonnull Collection&lt;@Nonnull String&gt; preDestroyAnnotations
        ) throws Exception {
<span class="fc" id="L592">            Class&lt;?&gt; rawClass = rawClass(type);</span>
            // fields
<span class="fc" id="L594">            Field[] fields = rawClass.getDeclaredFields();</span>
<span class="fc" id="L595">            ArrayList&lt;Field&gt; dependencyFields = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            for (Field field : fields) {</span>
<span class="fc" id="L597">                int mod = field.getModifiers();</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">                if (Modifier.isFinal(mod)) {</span>
<span class="fc" id="L599">                    continue;</span>
                }
<span class="fc bfc" id="L601" title="All 2 branches covered.">                for (Annotation annotation : field.getAnnotations()) {</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">                    if (resourceAnnotations.contains(annotation.annotationType().getName())) {</span>
<span class="fc" id="L603">                        dependencyFields.add(field);</span>
                    }
                }
            }
<span class="fc" id="L607">            dependencyFields.trimToSize();</span>
<span class="fc" id="L608">            List&lt;Field&gt; depFields = Collections.unmodifiableList(dependencyFields);</span>
            // methods
<span class="fc" id="L610">            Method postConstruct = null;</span>
<span class="fc" id="L611">            Method preDestroy = null;</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">            for (Method method : rawClass.getMethods()) {</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">                for (Annotation annotation : method.getAnnotations()) {</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">                    if (postConstructAnnotations.contains(annotation.annotationType().getName())) {</span>
<span class="fc" id="L615">                        postConstruct = method;</span>
                    }
<span class="fc bfc" id="L617" title="All 2 branches covered.">                    if (preDestroyAnnotations.contains(annotation.annotationType().getName())) {</span>
<span class="fc" id="L618">                        preDestroy = method;</span>
                    }
                }
            }
<span class="fc" id="L622">            Method postConstructMethod = postConstruct;</span>
<span class="fc" id="L623">            Method preDestroyMethod = preDestroy;</span>
<span class="fc" id="L624">            return new InjectedResource.Descriptor() {</span>
                @Override
                public @Nonnull Type type() {
<span class="fc" id="L627">                    return type;</span>
                }

                @Override
                public @Nonnull Class&lt;?&gt; rawClass() {
<span class="fc" id="L632">                    return rawClass;</span>
                }

                @Override
                public @Nullable Method postConstructMethod() {
<span class="fc" id="L637">                    return postConstructMethod;</span>
                }

                @Override
                public @Nullable Method preDestroyMethod() {
<span class="fc" id="L642">                    return preDestroyMethod;</span>
                }

                @Override
                public @Nonnull @Immutable List&lt;@Nonnull Field&gt; dependencyFields() {
<span class="fc" id="L647">                    return depFields;</span>
                }
            };
        }
    }

<span class="fc" id="L653">    enum FieldSetter implements InjectedResource.FieldSetter {</span>

<span class="fc" id="L655">        INST;</span>

        @Override
        public void set(@Nonnull Field field, @Nonnull Object owner, @Nonnull Object value) throws Exception {
<span class="fc" id="L659">            field.setAccessible(true);</span>
<span class="fc" id="L660">            field.set(owner, value);</span>
<span class="fc" id="L661">        }</span>
    }

<span class="fc" id="L664">    private enum PostConstructComparator implements Comparator&lt;InjectedResource&gt; {</span>

<span class="fc" id="L666">        INST;</span>

        @Override
        public int compare(@Nonnull InjectedResource sr1, @Nonnull InjectedResource sr2) {
<span class="fc" id="L670">            Method pc1 = Fs.asNonnull(sr1.postConstructMethod());</span>
<span class="fc" id="L671">            Method pc2 = Fs.asNonnull(sr2.postConstructMethod());</span>
            // InjectedDependsOn sd1 = pc1.getAnnotation(InjectedDependsOn.class);
            // InjectedDependsOn sd2 = pc2.getAnnotation(InjectedDependsOn.class);
<span class="fc" id="L674">            Type[] sd1 = pc1.getGenericParameterTypes();</span>
<span class="fc" id="L675">            Type[] sd2 = pc2.getGenericParameterTypes();</span>
<span class="fc" id="L676">            return compareDependsOn(sr1, sd1, sr2, sd2);</span>
        }
    }

<span class="fc" id="L680">    private enum PreDestroyComparator implements Comparator&lt;InjectedResource&gt; {</span>

<span class="fc" id="L682">        INST;</span>

        @Override
        public int compare(@Nonnull InjectedResource sr1, @Nonnull InjectedResource sr2) {
<span class="fc" id="L686">            Method pd1 = Fs.asNonnull(sr1.preDestroyMethod());</span>
<span class="fc" id="L687">            Method pd2 = Fs.asNonnull(sr2.preDestroyMethod());</span>
            // InjectedDependsOn sd1 = pd1.getAnnotation(InjectedDependsOn.class);
            // InjectedDependsOn sd2 = pd2.getAnnotation(InjectedDependsOn.class);
<span class="fc" id="L690">            Type[] sd1 = pd1.getGenericParameterTypes();</span>
<span class="fc" id="L691">            Type[] sd2 = pd2.getGenericParameterTypes();</span>
<span class="fc" id="L692">            return compareDependsOn(sr1, sd1, sr2, sd2);</span>
        }
    }

    // private static int compareDependsOn(
    //     @Nonnull InjectedResource sr1, @Nullable InjectedDependsOn sd1,
    //     @Nonnull InjectedResource sr2, @Nullable InjectedDependsOn sd2
    // ) {
    //     if (sd1 != null) {
    //         for (Class&lt;?&gt; c1 : sd1.value()) {
    //             if (c1.equals(sr2.type())) {
    //                 return 1;
    //             }
    //         }
    //     }
    //     if (sd2 != null) {
    //         for (Class&lt;?&gt; c2 : sd2.value()) {
    //             if (c2.equals(sr1.type())) {
    //                 return -1;
    //             }
    //         }
    //     }
    //     return 0;
    // }

    private static int compareDependsOn(
        @Nonnull InjectedResource sr1, Type @Nonnull [] sd1,
        @Nonnull InjectedResource sr2, Type @Nonnull [] sd2
    ) {
<span class="fc bfc" id="L721" title="All 2 branches covered.">        for (Type c1 : sd1) {</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">            if (c1.equals(sr2.type())) {</span>
<span class="fc" id="L723">                return 1;</span>
            }
        }
<span class="fc bfc" id="L726" title="All 2 branches covered.">        for (Type c2 : sd2) {</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">            if (c2.equals(sr1.type())) {</span>
<span class="fc" id="L728">                return -1;</span>
            }
        }
<span class="fc" id="L731">        return 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>