<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CharsBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.fs.base.chars</a> &gt; <span class="el_source">CharsBuilder.java</span></div><h1>CharsBuilder.java</h1><pre class="source lang-java linenums">package space.sunqian.fs.base.chars;

import space.sunqian.annotation.Nonnull;
import space.sunqian.fs.base.Checker;
import space.sunqian.fs.io.BufferKit;
import space.sunqian.fs.io.IOKit;
import space.sunqian.fs.io.IORuntimeException;

import java.io.CharArrayWriter;
import java.io.Reader;
import java.io.Writer;
import java.nio.CharBuffer;
import java.util.Arrays;

/**
 * {@code CharsBuilder} is used to build char arrays and their derived objects by appending char data. It is similar to
 * {@link CharArrayWriter}, provides compatible methods, but is not thread-safe. This class is also the subtype of the
 * {@link Writer} and {@link CharSequence}, but the {@code close()} method has no effect.
 *
 * @author sunqian
 */
public class CharsBuilder extends Writer implements CharSequence {

    // Max array size.
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    private final int maxSize;

    private char @Nonnull [] buf;
    private int count;

    /**
     * Constructs with 32-chars initial capacity.
     */
    public CharsBuilder() {
<span class="fc" id="L36">        this(32);</span>
<span class="fc" id="L37">    }</span>

    /**
     * Constructs with the specified initial capacity in chars.
     *
     * @param initialCapacity the specified initial capacity in chars
     * @throws IllegalArgumentException if size is negative
     */
    public CharsBuilder(int initialCapacity) throws IllegalArgumentException {
<span class="fc" id="L46">        this(initialCapacity, MAX_ARRAY_SIZE);</span>
<span class="fc" id="L47">    }</span>

    /**
     * Constructs with the specified initial capacity and the max capacity in bytes.
     *
     * @param initialCapacity the specified initial capacity in bytes
     * @param maxCapacity     the max capacity in bytes
     * @throws IllegalArgumentException if the {@code initialCapacity &lt; 0} or {@code maxCapacity &lt; 0} or
     *                                  {@code initialCapacity &gt; maxCapacity}
     */
<span class="fc" id="L57">    public CharsBuilder(int initialCapacity, int maxCapacity) throws IllegalArgumentException {</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">        if (initialCapacity &lt; 0) {</span>
<span class="fc" id="L59">            throw new IllegalArgumentException(&quot;Negative initial capacity: &quot; + initialCapacity + &quot;.&quot;);</span>
        }
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (maxCapacity &lt; 0) {</span>
<span class="fc" id="L62">            throw new IllegalArgumentException(&quot;Negative max capacity: &quot; + maxCapacity + &quot;.&quot;);</span>
        }
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (initialCapacity &gt; maxCapacity) {</span>
<span class="fc" id="L65">            throw new IllegalArgumentException(&quot;Initial capacity must &lt;= max capacity!&quot;);</span>
        }
<span class="fc" id="L67">        buf = new char[initialCapacity];</span>
<span class="fc" id="L68">        this.maxSize = maxCapacity;</span>
<span class="fc" id="L69">    }</span>

    /**
     * Appends the specified char to this builder.
     *
     * @param b the specified char
     */
    public void write(int b) {
<span class="fc" id="L77">        ensureCapacity(count + 1);</span>
<span class="fc" id="L78">        buf[count] = (char) b;</span>
<span class="fc" id="L79">        count += 1;</span>
<span class="fc" id="L80">    }</span>

    /**
     * Appends all chars from the given array.
     *
     * @param cbuf the given array
     */
    public void write(char @Nonnull [] cbuf) {
<span class="fc" id="L88">        ensureCapacity(count + cbuf.length);</span>
<span class="fc" id="L89">        System.arraycopy(cbuf, 0, buf, count, cbuf.length);</span>
<span class="fc" id="L90">        count += cbuf.length;</span>
<span class="fc" id="L91">    }</span>

    /**
     * Appends the specified number of chars from the given array, starting at the specified offset.
     *
     * @param cbuf the given array
     * @param off  the specified offset
     * @param len  the specified number
     * @throws IndexOutOfBoundsException if the offset or number is out of bounds
     */
    public void write(char @Nonnull [] cbuf, int off, int len) throws IndexOutOfBoundsException {
<span class="fc" id="L102">        Checker.checkOffLen(off, len, cbuf.length);</span>
<span class="fc" id="L103">        ensureCapacity(count + len);</span>
<span class="fc" id="L104">        System.arraycopy(cbuf, off, buf, count, len);</span>
<span class="fc" id="L105">        count += len;</span>
<span class="fc" id="L106">    }</span>

    /**
     * Writes the appended data of this builder to the specified writer.
     *
     * @param out the specified writer
     * @throws IORuntimeException if an I/O error occurs
     */
    public void writeTo(@Nonnull Writer out) throws IORuntimeException {
        try {
<span class="fc" id="L116">            out.write(buf, 0, count);</span>
<span class="fc" id="L117">        } catch (Exception e) {</span>
<span class="fc" id="L118">            throw new IORuntimeException(e);</span>
<span class="fc" id="L119">        }</span>
<span class="fc" id="L120">    }</span>

    /**
     * Writes the appended buffered data of this builder to the specified buffer.
     *
     * @param out the specified buffer
     * @throws IORuntimeException if an I/O error occurs
     */
    public void writeTo(@Nonnull CharBuffer out) throws IORuntimeException {
        try {
<span class="fc" id="L130">            out.put(buf, 0, count);</span>
<span class="fc" id="L131">        } catch (Exception e) {</span>
<span class="fc" id="L132">            throw new IORuntimeException(e);</span>
<span class="fc" id="L133">        }</span>
<span class="fc" id="L134">    }</span>

    /**
     * Resets this builder, the appended data will be discarded.
     * &lt;p&gt;
     * This method doesn't guarantee releasing the allocated space for the appended data. To trim and release the unused
     * space, use {@link #trim()}.
     */
    public void reset() {
<span class="fc" id="L143">        count = 0;</span>
<span class="fc" id="L144">    }</span>

    /**
     * Trims and releases the allocated but unused space.
     */
    public void trim() {
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (count &lt; buf.length) {</span>
<span class="fc" id="L151">            buf = Arrays.copyOf(buf, count);</span>
        }
<span class="fc" id="L153">    }</span>

    /**
     * Returns the size of appended data.
     *
     * @return the size of appended data
     */
    public int size() {
<span class="fc" id="L161">        return count;</span>
    }

    /**
     * Returns a new array containing a copy of the appended data.
     *
     * @return a new array containing a copy of the appended data
     */
    public char @Nonnull [] toCharArray() {
<span class="fc" id="L170">        return Arrays.copyOf(buf, count);</span>
    }

    /**
     * Returns a new buffer containing a copy of the appended data.
     *
     * @return a new buffer containing a copy of the appended data
     */
    public @Nonnull CharBuffer toCharBuffer() {
<span class="fc" id="L179">        return CharBuffer.wrap(toCharArray());</span>
    }

    /**
     * Returns a string from a copy of the appended data.
     *
     * @return a string from a copy of the appended data
     */
    public @Nonnull String toString() {
<span class="fc" id="L188">        return new String(buf, 0, count);</span>
    }

    /**
     * No effect for this builder.
     */
    @Override
    public void flush() {
<span class="fc" id="L196">    }</span>

    /**
     * No effect for this builder.
     */
    @Override
    public void close() {
<span class="fc" id="L203">    }</span>

    /**
     * Appends the specified char to this builder.
     *
     * @param c the specified char
     * @return this builder
     */
    public @Nonnull CharsBuilder append(int c) {
<span class="fc" id="L212">        write(c);</span>
<span class="fc" id="L213">        return this;</span>
    }

    /**
     * Appends the specified char to this builder.
     *
     * @param c the specified char
     * @return this builder
     */
    public @Nonnull CharsBuilder append(char c) {
<span class="fc" id="L223">        write(c);</span>
<span class="fc" id="L224">        return this;</span>
    }

    /**
     * Appends all chars from the given array.
     *
     * @param chars the given array
     * @return this builder
     */
    public @Nonnull CharsBuilder append(char @Nonnull [] chars) {
<span class="fc" id="L234">        write(chars);</span>
<span class="fc" id="L235">        return this;</span>
    }

    /**
     * Appends the specified number of chars from the given array, starting at the specified offset.
     *
     * @param chars  the given array
     * @param offset the specified offset
     * @param length the specified number
     * @return this builder
     * @throws IndexOutOfBoundsException if the offset or number is out of bounds
     */
    public @Nonnull CharsBuilder append(
        char @Nonnull [] chars, int offset, int length
    ) throws IndexOutOfBoundsException {
<span class="fc" id="L250">        write(chars, offset, length);</span>
<span class="fc" id="L251">        return this;</span>
    }

    /**
     * Reads and appends all chars from the given buffer.
     *
     * @param chars the given buffer
     * @return this builder
     */
    public @Nonnull CharsBuilder append(@Nonnull CharBuffer chars) {
<span class="fc" id="L261">        int remaining = chars.remaining();</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (remaining == 0) {</span>
<span class="fc" id="L263">            return this;</span>
        }
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (chars.hasArray()) {</span>
<span class="fc" id="L266">            write(chars.array(), BufferKit.arrayStartIndex(chars), chars.remaining());</span>
<span class="fc" id="L267">            chars.position(chars.position() + chars.remaining());</span>
        } else {
<span class="fc" id="L269">            char[] data = new char[remaining];</span>
<span class="fc" id="L270">            chars.get(data);</span>
<span class="fc" id="L271">            write(data);</span>
        }
<span class="fc" id="L273">        return this;</span>
    }

    /**
     * Reads and appends all chars from the given reader.
     *
     * @param reader the given reader
     * @return this builder
     * @throws IORuntimeException if an I/O error occurs
     */
    public @Nonnull CharsBuilder append(@Nonnull Reader reader) throws IORuntimeException {
<span class="fc" id="L284">        return append(reader, IOKit.bufferSize());</span>
    }

    /**
     * Reads and appends all chars from the given reader with the specified buffer size for each reading.
     *
     * @param reader  the given reader
     * @param bufSize the specified buffer size for each reading
     * @return this builder
     * @throws IllegalArgumentException if the buffer size {@code &lt;= 0}
     * @throws IORuntimeException       if an I/O error occurs
     */
    public @Nonnull CharsBuilder append(
        @Nonnull Reader reader, int bufSize
    ) throws IllegalArgumentException, IORuntimeException {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (bufSize &lt;= 0) {</span>
<span class="fc" id="L300">            throw new IllegalArgumentException(&quot;The buffer size must &gt; 0.&quot;);</span>
        }
<span class="fc" id="L302">        char[] buffer = new char[bufSize];</span>
        while (true) {
            try {
<span class="fc" id="L305">                int readSize = reader.read(buffer);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                if (readSize &lt; 0) {</span>
<span class="fc" id="L307">                    return this;</span>
                }
<span class="fc" id="L309">                write(buffer, 0, readSize);</span>
<span class="fc" id="L310">            } catch (Exception e) {</span>
<span class="fc" id="L311">                throw new IORuntimeException(e);</span>
<span class="fc" id="L312">            }</span>
        }
    }

    /**
     * Appends all chars from the given builder.
     *
     * @param builder the given reader
     * @return this builder
     */
    public @Nonnull CharsBuilder append(@Nonnull CharsBuilder builder) {
<span class="fc" id="L323">        write(builder.buf, 0, builder.count);</span>
<span class="fc" id="L324">        return this;</span>
    }

    @Override
    public int length() {
<span class="fc" id="L329">        return count;</span>
    }

    @Override
    public char charAt(int index) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (index &gt;= count) {</span>
<span class="fc" id="L335">            throw new IndexOutOfBoundsException(&quot;Index out of bounds: &quot; + index + &quot;.&quot;);</span>
        }
<span class="fc" id="L337">        return buf[index];</span>
    }

    @Override
    public @Nonnull CharSequence subSequence(int start, int end) {
<span class="fc" id="L342">        return toString().subSequence(start, end);</span>
    }

    private void ensureCapacity(int minCapacity) {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (buf.length &lt; minCapacity) {</span>
<span class="fc" id="L347">            grow(minCapacity);</span>
        }
<span class="fc" id="L349">    }</span>

    private void grow(int minCapacity) {
<span class="fc bfc" id="L352" title="All 4 branches covered.">        if (minCapacity &lt; 0 || minCapacity &gt; maxSize) {</span>
<span class="fc" id="L353">            throw new IllegalStateException(&quot;Buffer out of size: &quot; + minCapacity + &quot;.&quot;);</span>
        }
<span class="fc" id="L355">        int oldCapacity = buf.length;</span>
        int newCapacity;
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (oldCapacity == 0) {</span>
<span class="fc" id="L358">            newCapacity = minCapacity;</span>
        } else {
<span class="fc" id="L360">            newCapacity = oldCapacity * 2;</span>
        }
<span class="fc" id="L362">        newCapacity = newCapacity(newCapacity, minCapacity);</span>
<span class="fc" id="L363">        buf = Arrays.copyOf(buf, newCapacity);</span>
<span class="fc" id="L364">    }</span>

    private int newCapacity(int newCapacity, int minCapacity) {
<span class="fc bfc" id="L367" title="All 4 branches covered.">        if (newCapacity &lt;= 0 || newCapacity &gt; maxSize) {</span>
<span class="fc" id="L368">            return maxSize;</span>
        }
<span class="fc" id="L370">        return Math.max(newCapacity, minCapacity);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>