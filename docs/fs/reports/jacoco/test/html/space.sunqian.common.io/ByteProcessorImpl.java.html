<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteProcessorImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.io</a> &gt; <span class="el_source">ByteProcessorImpl.java</span></div><h1>ByteProcessorImpl.java</h1><pre class="source lang-java linenums">package space.sunqian.common.io;

import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.common.base.chars.CharsKit;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.WritableByteChannel;
import java.util.ArrayList;
import java.util.List;

final class ByteProcessorImpl implements ByteProcessor {

    private final @Nonnull ByteReader src;
<span class="fc" id="L18">    private long readLimit = -1;</span>
<span class="fc" id="L19">    private int readBlockSize = IOKit.bufferSize();</span>
<span class="fc" id="L20">    private @Nullable List&lt;ByteTransformer&gt; transformers = null;</span>

<span class="fc" id="L22">    ByteProcessorImpl(@Nonnull ByteReader src) {</span>
<span class="fc" id="L23">        this.src = src;</span>
<span class="fc" id="L24">    }</span>

    @Override
    public @Nonnull ByteProcessor readLimit(long readLimit) throws IllegalArgumentException {
<span class="fc" id="L28">        IOChecker.checkReadLimit(readLimit);</span>
<span class="fc" id="L29">        this.readLimit = readLimit;</span>
<span class="fc" id="L30">        return this;</span>
    }

    @Override
    public @Nonnull ByteProcessor readBlockSize(int readBlockSize) throws IllegalArgumentException {
<span class="fc" id="L35">        IOChecker.checkReadBlockSize(readBlockSize);</span>
<span class="fc" id="L36">        this.readBlockSize = readBlockSize;</span>
<span class="fc" id="L37">        return this;</span>
    }

    @Override
    public @Nonnull ByteProcessor transformer(@Nonnull ByteTransformer transformer) {
<span class="fc bfc" id="L42" title="All 2 branches covered.">        if (transformers == null) {</span>
<span class="fc" id="L43">            transformers = new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L45">        transformers.add(transformer);</span>
<span class="fc" id="L46">        return this;</span>
    }

    @Override
    public long processTo(@Nonnull OutputStream dst) throws IORuntimeException {
        try {
<span class="fc bfc" id="L52" title="All 2 branches covered.">            if (transformers == null) {</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">                ByteReader reader = readLimit &lt; 0 ? src : src.limit(readLimit);</span>
<span class="fc" id="L54">                return reader.readTo(dst);</span>
            }
<span class="fc" id="L56">            return process(dst, transformers);</span>
<span class="fc" id="L57">        } catch (Exception e) {</span>
<span class="fc" id="L58">            throw new IORuntimeException(e);</span>
        }
    }

    @Override
    public long processTo(@Nonnull WritableByteChannel dst) throws IORuntimeException {
        try {
<span class="fc bfc" id="L65" title="All 2 branches covered.">            if (transformers == null) {</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">                ByteReader reader = readLimit &lt; 0 ? src : src.limit(readLimit);</span>
<span class="fc" id="L67">                return reader.readTo(dst);</span>
            }
<span class="fc" id="L69">            return process(dst, transformers);</span>
<span class="fc" id="L70">        } catch (Exception e) {</span>
<span class="fc" id="L71">            throw new IORuntimeException(e);</span>
        }
    }

    @Override
    public long processTo(byte @Nonnull [] dst) throws IORuntimeException {
        try {
<span class="fc" id="L78">            OutputStream out = IOKit.newOutputStream(dst);</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            if (transformers == null) {</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">                ByteReader reader = readLimit &lt; 0 ? src : src.limit(readLimit);</span>
<span class="fc" id="L81">                return reader.readTo(out);</span>
            }
<span class="fc" id="L83">            return process(out, transformers);</span>
<span class="fc" id="L84">        } catch (Exception e) {</span>
<span class="fc" id="L85">            throw new IORuntimeException(e);</span>
        }
    }

    @Override
    public long processTo(byte @Nonnull [] dst, int off) throws IndexOutOfBoundsException, IORuntimeException {
<span class="fc" id="L91">        OutputStream out = IOKit.newOutputStream(dst, off, dst.length - off);</span>
        try {
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if (transformers == null) {</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                ByteReader reader = readLimit &lt; 0 ? src : src.limit(readLimit);</span>
<span class="fc" id="L95">                return reader.readTo(out);</span>
            }
<span class="fc" id="L97">            return process(out, transformers);</span>
<span class="fc" id="L98">        } catch (Exception e) {</span>
<span class="fc" id="L99">            throw new IORuntimeException(e);</span>
        }
    }

    @Override
    public long processTo(@Nonnull ByteBuffer dst) throws IORuntimeException {
        try {
<span class="fc" id="L106">            OutputStream out = IOKit.newOutputStream(dst);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (transformers == null) {</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">                ByteReader reader = readLimit &lt; 0 ? src : src.limit(readLimit);</span>
<span class="fc" id="L109">                return reader.readTo(out);</span>
            }
<span class="fc" id="L111">            return process(out, transformers);</span>
<span class="fc" id="L112">        } catch (Exception e) {</span>
<span class="fc" id="L113">            throw new IORuntimeException(e);</span>
        }
    }

    @Override
    public @Nonnull String toString() {
<span class="fc" id="L119">        return new String(toByteArray(), CharsKit.defaultCharset());</span>
    }

    private long process(@Nonnull Object dst, @Nonnull List&lt;@Nonnull ByteTransformer&gt; transformers) throws Exception {
<span class="fc bfc" id="L123" title="All 2 branches covered.">        ByteReader reader = readLimit &lt; 0 ? src : src.limit(readLimit);</span>
<span class="fc" id="L124">        long count = 0;</span>
        while (true) {
<span class="fc" id="L126">            ByteSegment block = reader.read(readBlockSize);</span>
<span class="fc" id="L127">            ByteBuffer data = block.data();</span>
<span class="fc" id="L128">            count += data.remaining();</span>
<span class="fc" id="L129">            boolean end = block.end();</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            for (ByteTransformer transformer : transformers) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">                if (data == null) {</span>
<span class="fc" id="L132">                    break;</span>
                }
<span class="fc" id="L134">                data = transformer.transform(data, end);</span>
<span class="fc" id="L135">            }</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (data != null) {</span>
<span class="fc" id="L137">                writeTo(data, dst);</span>
            }
<span class="fc bfc" id="L139" title="All 2 branches covered.">            if (end) {</span>
<span class="fc" id="L140">                break;</span>
            }
<span class="fc" id="L142">        }</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        return count == 0L ? -1 : count;</span>
    }

    private void writeTo(@Nonnull ByteBuffer data, @Nonnull Object dst) {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (dst instanceof OutputStream) {</span>
<span class="fc" id="L148">            BufferKit.readTo(data, (OutputStream) dst);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        } else if (dst instanceof WritableByteChannel) {</span>
<span class="fc" id="L150">            BufferKit.readTo(data, (WritableByteChannel) dst);</span>
        } else {
<span class="fc" id="L152">            throw new UnsupportedOperationException(&quot;Unsupported destination: &quot; + dst.getClass() + &quot;.&quot;);</span>
        }
<span class="fc" id="L154">    }</span>

    @Override
    public @Nonnull InputStream asInputStream() {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        ByteReader reader = readLimit &lt; 0 ? src : src.limit(readLimit);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (transformers == null) {</span>
<span class="fc" id="L160">            return reader.asInputStream();</span>
        }
<span class="fc" id="L162">        return new EncoderInputStream(reader, readBlockSize, transformers);</span>
    }

    @Override
    public @Nonnull ByteReader asByteReader() {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (transformers == null) {</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            return readLimit &lt; 0 ? src : src.limit(readLimit);</span>
        }
<span class="fc" id="L170">        return ByteReader.from(asInputStream());</span>
    }

    private static final class EncoderInputStream extends InputStream {

        private final @Nonnull ByteReader reader;
        private final int readBlockSize;
        private final @Nonnull List&lt;@Nonnull ByteTransformer&gt; transformers;

<span class="fc" id="L179">        private @Nullable ByteSegment nextSeg = null;</span>
<span class="fc" id="L180">        private boolean closed = false;</span>

        private EncoderInputStream(
            @Nonnull ByteReader reader, int readBlockSize, @Nonnull List&lt;@Nonnull ByteTransformer&gt; transformers
<span class="fc" id="L184">        ) {</span>
<span class="fc" id="L185">            this.reader = reader;</span>
<span class="fc" id="L186">            this.readBlockSize = readBlockSize;</span>
<span class="fc" id="L187">            this.transformers = transformers;</span>
<span class="fc" id="L188">        }</span>

        private @Nonnull ByteSegment nextSeg() throws IOException {
            try {
                ByteSegment next;
                do {
<span class="fc" id="L194">                    next = next();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">                } while (next == null);</span>
<span class="fc" id="L196">                return next;</span>
<span class="fc" id="L197">            } catch (Exception e) {</span>
<span class="fc" id="L198">                throw new IOException(e);</span>
            }
        }

        private @Nullable ByteSegment next() throws Exception {
<span class="fc" id="L203">            ByteSegment block = reader.read(readBlockSize);</span>
<span class="fc" id="L204">            ByteBuffer data = block.data();</span>
<span class="fc" id="L205">            boolean end = block.end();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            for (ByteTransformer transformer : transformers) {</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">                if (data == null) {</span>
<span class="fc" id="L208">                    break;</span>
                }
<span class="fc" id="L210">                data = transformer.transform(data, end);</span>
<span class="fc" id="L211">            }</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (data == null) {</span>
<span class="fc" id="L213">                return null;</span>
            }
<span class="fc bfc" id="L215" title="All 2 branches covered.">            if (data == block.data()) {</span>
<span class="fc" id="L216">                return block;</span>
            }
<span class="fc" id="L218">            return ByteSegment.of(data, end);</span>
        }

        @Override
        public int read() throws IOException {
<span class="fc" id="L223">            checkClosed();</span>
            while (true) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">                if (nextSeg == null) {</span>
<span class="fc" id="L226">                    nextSeg = nextSeg();</span>
                }
<span class="fc bfc" id="L228" title="All 2 branches covered.">                if (nextSeg == ByteSegment.empty(true)) {</span>
<span class="fc" id="L229">                    return -1;</span>
                }
<span class="fc bfc" id="L231" title="All 2 branches covered.">                if (nextSeg.data().hasRemaining()) {</span>
<span class="fc" id="L232">                    return nextSeg.data().get() &amp; 0xff;</span>
                }
<span class="fc bfc" id="L234" title="All 2 branches covered.">                if (nextSeg.end()) {</span>
<span class="fc" id="L235">                    nextSeg = ByteSegment.empty(true);</span>
<span class="fc" id="L236">                    return -1;</span>
                }
<span class="fc" id="L238">                nextSeg = null;</span>
            }
        }

        @Override
        public int read(byte @Nonnull [] b) throws IOException {
<span class="fc" id="L244">            return read(b, 0, b.length);</span>
        }

        @Override
        public int read(byte @Nonnull [] dst, int off, int len) throws IOException {
<span class="fc" id="L249">            checkClosed();</span>
<span class="fc" id="L250">            IOChecker.checkOffLen(off, len, dst.length);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L252">                return 0;</span>
            }
<span class="fc" id="L254">            return read0(dst, off, len);</span>
        }

        @Override
        public long skip(long n) throws IOException {
<span class="fc" id="L259">            checkClosed();</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (n &lt;= 0) {</span>
<span class="fc" id="L261">                return 0;</span>
            }
<span class="fc" id="L263">            return read0(null, 0, n);</span>
        }

        private int read0(byte @Nullable [] dst, int off, long len) throws IOException {
<span class="fc" id="L267">            int pos = 0;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            while (pos &lt; len) {</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                if (nextSeg == null) {</span>
<span class="fc" id="L270">                    nextSeg = nextSeg();</span>
                }
<span class="fc bfc" id="L272" title="All 2 branches covered.">                if (nextSeg == ByteSegment.empty(true)) {</span>
<span class="fc" id="L273">                    break;</span>
                }
<span class="fc" id="L275">                ByteBuffer data = nextSeg.data();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                if (data.hasRemaining()) {</span>
<span class="fc" id="L277">                    int readSize = (int) Math.min(data.remaining(), len - pos);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                    if (dst != null) {</span>
<span class="fc" id="L279">                        data.get(dst, pos + off, readSize);</span>
                    } else {
<span class="fc" id="L281">                        data.position(data.position() + readSize);</span>
                    }
<span class="fc" id="L283">                    pos += readSize;</span>
<span class="fc" id="L284">                    continue;</span>
                }
<span class="fc bfc" id="L286" title="All 2 branches covered.">                if (nextSeg.end()) {</span>
<span class="fc" id="L287">                    nextSeg = ByteSegment.empty(true);</span>
<span class="fc" id="L288">                    break;</span>
                }
<span class="fc" id="L290">                nextSeg = null;</span>
<span class="fc" id="L291">            }</span>
<span class="fc bfc" id="L292" title="All 4 branches covered.">            return pos == 0 ? (dst == null ? 0 : -1) : pos;</span>
        }

        @Override
        public int available() {
<span class="fc bfc" id="L297" title="All 2 branches covered.">            return nextSeg == null ? 0 : nextSeg.data().remaining();</span>
        }

        @Override
        public void close() throws IOException {
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (closed) {</span>
<span class="fc" id="L303">                return;</span>
            }
            try {
<span class="fc" id="L306">                reader.close();</span>
<span class="fc" id="L307">            } catch (Exception e) {</span>
<span class="fc" id="L308">                throw new IOException(e);</span>
<span class="fc" id="L309">            }</span>
<span class="fc" id="L310">            closed = true;</span>
<span class="fc" id="L311">        }</span>

        private void checkClosed() throws IOException {
<span class="fc bfc" id="L314" title="All 2 branches covered.">            if (closed) {</span>
<span class="fc" id="L315">                throw new IOException(&quot;Stream closed.&quot;);</span>
            }
<span class="fc" id="L317">        }</span>
    }

    private static abstract class ResidualSizeHandler implements ByteTransformer {

        protected final @Nonnull ByteTransformer transformer;
        protected final int size;

        // Residual data;
        // Its capacity is always the size.
        private @Nullable ByteBuffer residual;

<span class="fc" id="L329">        protected ResidualSizeHandler(@Nonnull ByteTransformer transformer, int size) throws IllegalArgumentException {</span>
<span class="fc" id="L330">            this.transformer = transformer;</span>
<span class="fc" id="L331">            this.size = size;</span>
<span class="fc" id="L332">        }</span>

        protected abstract @Nullable List&lt;ByteBuffer&gt; handleMultiple(
            @Nonnull ByteBuffer data, boolean end
        ) throws Exception;

        @Override
        public @Nullable ByteBuffer transform(@Nonnull ByteBuffer data, boolean end) throws Exception {

            // clean buffer
<span class="fc" id="L342">            ByteBuffer previousResult = null;</span>
<span class="fc bfc" id="L343" title="All 4 branches covered.">            if (residual != null &amp;&amp; residual.position() &gt; 0) {</span>
<span class="fc" id="L344">                BufferKit.readTo(data, residual);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                if (residual.hasRemaining()) {</span>
                    // in this case data must be empty
<span class="fc bfc" id="L347" title="All 2 branches covered.">                    if (end) {</span>
<span class="fc" id="L348">                        residual.flip();</span>
<span class="fc" id="L349">                        return transformer.transform(residual, true);</span>
                    } else {
<span class="fc" id="L351">                        return null;</span>
                    }
                } else {
<span class="fc" id="L354">                    residual.flip();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">                    if (end) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                        if (data.hasRemaining()) {</span>
<span class="fc" id="L357">                            previousResult = transformer.transform(BufferKit.copy(residual), false);</span>
                        } else {
<span class="fc" id="L359">                            return transformer.transform(residual, true);</span>
                        }
                    } else {
<span class="fc" id="L362">                        previousResult = transformer.transform(BufferKit.copy(residual), false);</span>
                    }
<span class="fc" id="L364">                    residual.clear();</span>
                }
            }

            // multiple
<span class="fc" id="L369">            List&lt;ByteBuffer&gt; multipleResult = handleMultiple(data, end);</span>

            // remainder
<span class="fc" id="L372">            ByteBuffer residualResult = null;</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (data.hasRemaining()) {</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">                if (residual == null) {</span>
<span class="fc" id="L375">                    residual = ByteBuffer.allocate(size);</span>
                }
<span class="fc" id="L377">                BufferKit.readTo(data, residual);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                if (end) {</span>
<span class="fc" id="L379">                    residual.flip();</span>
<span class="fc" id="L380">                    residualResult = transformer.transform(residual, true);</span>
                }
            }

            // empty end
<span class="fc bfc" id="L385" title="All 8 branches covered.">            if (end &amp;&amp; previousResult == null &amp;&amp; multipleResult == null &amp;&amp; residualResult == null) {</span>
<span class="fc" id="L386">                return transformer.transform(ByteBuffer.allocate(0), true);</span>
            }

<span class="fc" id="L389">            return mergeResult(previousResult, multipleResult, residualResult);</span>
        }

        private @Nullable ByteBuffer mergeResult(
            @Nullable ByteBuffer previousResult,
            @Nullable List&lt;@Nonnull ByteBuffer&gt; multipleResult,
            @Nullable ByteBuffer residualResult
        ) {
<span class="fc" id="L397">            int totalSize = 0;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            if (previousResult != null) {</span>
<span class="fc" id="L399">                totalSize += previousResult.remaining();</span>
            }
<span class="fc bfc" id="L401" title="All 2 branches covered.">            if (multipleResult != null) {</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">                for (ByteBuffer buf : multipleResult) {</span>
<span class="fc" id="L403">                    totalSize += buf.remaining();</span>
<span class="fc" id="L404">                }</span>
            }
<span class="fc bfc" id="L406" title="All 2 branches covered.">            if (residualResult != null) {</span>
<span class="fc" id="L407">                totalSize += residualResult.remaining();</span>
            }
<span class="fc bfc" id="L409" title="All 2 branches covered.">            if (totalSize == 0) {</span>
<span class="fc" id="L410">                return null;</span>
            }
<span class="fc" id="L412">            ByteBuffer result = ByteBuffer.allocate(totalSize);</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">            if (previousResult != null) {</span>
<span class="fc" id="L414">                BufferKit.readTo(previousResult, result);</span>
            }
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (multipleResult != null) {</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                for (ByteBuffer buf : multipleResult) {</span>
<span class="fc" id="L418">                    BufferKit.readTo(buf, result);</span>
<span class="fc" id="L419">                }</span>
            }
<span class="fc bfc" id="L421" title="All 2 branches covered.">            if (residualResult != null) {</span>
<span class="fc" id="L422">                BufferKit.readTo(residualResult, result);</span>
            }
<span class="fc" id="L424">            result.flip();</span>
<span class="fc" id="L425">            return result;</span>
        }
    }

    static final class FixedSizeHandler extends ResidualSizeHandler {

        FixedSizeHandler(@Nonnull ByteTransformer transformer, int size) throws IllegalArgumentException {
<span class="fc" id="L432">            super(transformer, size);</span>
<span class="fc" id="L433">        }</span>

        @Override
        protected @Nullable List&lt;ByteBuffer&gt; handleMultiple(@Nonnull ByteBuffer data, boolean end) throws Exception {
<span class="fc" id="L437">            int remainingSize = data.remaining();</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (remainingSize &lt;= 0) {</span>
<span class="fc" id="L439">                return null;</span>
            }
<span class="fc" id="L441">            List&lt;ByteBuffer&gt; multipleResult = null;</span>
<span class="fc" id="L442">            int multipleSize = remainingSize / size * size;</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">            if (multipleSize &gt; 0) {</span>
<span class="fc" id="L444">                multipleResult = new ArrayList&lt;&gt;(multipleSize / size);</span>
<span class="fc" id="L445">                int curSize = multipleSize;</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">                while (curSize &gt; 0) {</span>
<span class="fc" id="L447">                    ByteBuffer multiple = BufferKit.slice0(data, 0, size);</span>
<span class="fc" id="L448">                    data.position(data.position() + size);</span>
<span class="fc bfc" id="L449" title="All 6 branches covered.">                    ByteBuffer multipleRet = transformer.transform(</span>
                        multiple,
                        end &amp;&amp; multipleSize == remainingSize &amp;&amp; curSize == size
                    );
<span class="fc" id="L453">                    multipleResult.add(multipleRet);</span>
<span class="fc" id="L454">                    curSize -= size;</span>
<span class="fc" id="L455">                }</span>
            }
<span class="fc" id="L457">            return multipleResult;</span>
        }
    }

    static final class MultipleSizeHandler extends ResidualSizeHandler {

<span class="fc" id="L463">        private final @Nonnull List&lt;ByteBuffer&gt; multipleResult = new ArrayList&lt;&gt;(1);</span>

        MultipleSizeHandler(@Nonnull ByteTransformer transformer, int size) throws IllegalArgumentException {
<span class="fc" id="L466">            super(transformer, size);</span>
<span class="fc" id="L467">        }</span>

        @Override
        protected @Nullable List&lt;ByteBuffer&gt; handleMultiple(@Nonnull ByteBuffer data, boolean end) throws Exception {
<span class="fc" id="L471">            int remainingSize = data.remaining();</span>
<span class="fc" id="L472">            int multipleSize = remainingSize / size * size;</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (multipleSize &lt;= 0) {</span>
<span class="fc" id="L474">                return null;</span>
            }
<span class="fc" id="L476">            ByteBuffer multiple = BufferKit.slice0(data, 0, multipleSize);</span>
<span class="fc" id="L477">            data.position(data.position() + multipleSize);</span>
<span class="fc bfc" id="L478" title="All 4 branches covered.">            ByteBuffer multipleRet = transformer.transform(</span>
                multiple,
                end &amp;&amp; multipleSize == remainingSize
            );
<span class="fc" id="L482">            multipleResult.add(multipleRet);</span>
<span class="fc" id="L483">            return multipleResult;</span>
        }
    }

    static final class BufferedHandler implements ByteTransformer {

        private final ByteTransformer transformer;
<span class="fc" id="L490">        private byte @Nullable [] buffer = null;</span>

<span class="fc" id="L492">        BufferedHandler(ByteTransformer transformer) {</span>
<span class="fc" id="L493">            this.transformer = transformer;</span>
<span class="fc" id="L494">        }</span>

        @Override
        public @Nullable ByteBuffer transform(@Nonnull ByteBuffer data, boolean end) throws Exception {
            ByteBuffer totalBuffer;
<span class="fc bfc" id="L499" title="All 2 branches covered.">            if (buffer != null) {</span>
<span class="fc" id="L500">                ByteBuffer newBuffer = ByteBuffer.allocate(buffer.length + data.remaining());</span>
<span class="fc" id="L501">                newBuffer.put(buffer);</span>
<span class="fc" id="L502">                newBuffer.put(data);</span>
<span class="fc" id="L503">                newBuffer.flip();</span>
<span class="fc" id="L504">                totalBuffer = newBuffer;</span>
<span class="fc" id="L505">            } else {</span>
<span class="fc" id="L506">                totalBuffer = data;</span>
            }
<span class="fc" id="L508">            ByteBuffer ret = transformer.transform(totalBuffer, end);</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (end) {</span>
<span class="fc" id="L510">                buffer = null;</span>
            } else {
<span class="fc" id="L512">                buffer = BufferKit.read(totalBuffer);</span>
            }
<span class="fc" id="L514">            return ret;</span>
        }
    }

<span class="fc" id="L518">    enum EmptyHandler implements ByteTransformer {</span>

<span class="fc" id="L520">        INST;</span>

        @Override
        public ByteBuffer transform(@Nonnull ByteBuffer data, boolean end) {
<span class="fc" id="L524">            return data;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>