<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CharReaderBack.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.io</a> &gt; <span class="el_source">CharReaderBack.java</span></div><h1>CharReaderBack.java</h1><pre class="source lang-java linenums">package space.sunqian.common.io;

import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.common.base.chars.CharsKit;
import space.sunqian.common.base.math.MathKit;
import space.sunqian.common.base.string.StringKit;
import space.sunqian.common.io.IOChecker.ReadChecker;

import java.io.IOException;
import java.io.Reader;
import java.nio.CharBuffer;

final class CharReaderBack {

    static @Nonnull CharReader of(@Nonnull Reader src, int bufSize) throws IllegalArgumentException {
<span class="fc" id="L17">        IOChecker.checkBufSize(bufSize);</span>
<span class="fc" id="L18">        return new CharStreamReader(src, bufSize);</span>
    }

    static @Nonnull CharReader of(char @Nonnull [] src, int off, int len) throws IndexOutOfBoundsException {
<span class="fc" id="L22">        IOChecker.checkOffLen(off, len, src.length);</span>
<span class="fc" id="L23">        return new CharArrayReader(src, off, len);</span>
    }

    static @Nonnull CharReader of(@Nonnull CharSequence src, int start, int end) throws IndexOutOfBoundsException {
<span class="fc" id="L27">        IOChecker.checkStartEnd(start, end, src.length());</span>
<span class="fc" id="L28">        return new CharSequenceReader(src, start, end);</span>
    }

    static @Nonnull CharReader of(@Nonnull CharBuffer src) {
<span class="fc" id="L32">        return new CharBufferReader(src);</span>
    }

    static @Nonnull CharReader limit(@Nonnull CharReader reader, long limit) throws IllegalArgumentException {
<span class="fc" id="L36">        IOChecker.checkLimit(limit);</span>
<span class="fc" id="L37">        return new LimitedReader(reader, limit);</span>
    }

    static @Nonnull CharSegment newSeg(@Nonnull CharBuffer data, boolean end) {
<span class="fc" id="L41">        return new CharSegmentImpl(data, end);</span>
    }

    static @Nonnull CharSegment emptySeg(boolean end) {
<span class="fc bfc" id="L45" title="All 2 branches covered.">        return end ? CharSegmentImpl.EMPTY_END : CharSegmentImpl.EMPTY_SEG;</span>
    }

    static @Nonnull Reader asReader(@Nonnull CharReader reader) {
<span class="fc" id="L49">        return new AsReader(reader);</span>
    }

    private static final class CharSegmentImpl implements CharSegment {

<span class="fc" id="L54">        private static final @Nonnull CharSegmentImpl EMPTY_END = new CharSegmentImpl(CharsKit.emptyBuffer(), true);</span>
<span class="fc" id="L55">        private static final @Nonnull CharSegmentImpl EMPTY_SEG = new CharSegmentImpl(CharsKit.emptyBuffer(), false);</span>

        private final @Nonnull CharBuffer data;
        private final boolean end;

<span class="fc" id="L60">        private CharSegmentImpl(@Nonnull CharBuffer data, boolean end) {</span>
<span class="fc" id="L61">            this.data = data;</span>
<span class="fc" id="L62">            this.end = end;</span>
<span class="fc" id="L63">        }</span>

        @Override
        public @Nonnull CharBuffer data() {
<span class="fc" id="L67">            return data;</span>
        }

        @Override
        public boolean end() {
<span class="fc" id="L72">            return end;</span>
        }

        @SuppressWarnings(&quot;MethodDoesntCallSuperMethod&quot;)
        @Override
        public @Nonnull CharSegment clone() {
<span class="fc" id="L78">            CharBuffer copy = CharBuffer.allocate(data.remaining());</span>
<span class="fc" id="L79">            int pos = data.position();</span>
<span class="fc" id="L80">            int limit = data.limit();</span>
<span class="fc" id="L81">            copy.put(data);</span>
<span class="fc" id="L82">            data.position(pos);</span>
<span class="fc" id="L83">            data.limit(limit);</span>
<span class="fc" id="L84">            copy.flip();</span>
<span class="fc" id="L85">            return CharSegment.of(copy, end);</span>
        }
    }

    private static final class CharStreamReader implements CharReader {

        private final @Nonnull Reader src;
        private final int bufSize;

<span class="fc" id="L94">        private CharStreamReader(@Nonnull Reader src, int bufSize) {</span>
<span class="fc" id="L95">            this.src = src;</span>
<span class="fc" id="L96">            this.bufSize = bufSize;</span>
<span class="fc" id="L97">        }</span>

        @Override
        public int ready() {
<span class="fc" id="L101">            return 0;</span>
        }

        @Override
        public @Nonnull CharSegment read(int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L106">            IOChecker.checkLen(len);</span>
<span class="fc" id="L107">            char[] data = IOKit.read0(src, len, bufSize, IOChecker.endChecker());</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (data == null) {</span>
<span class="fc" id="L109">                return CharSegment.empty(true);</span>
            }
<span class="fc bfc" id="L111" title="All 2 branches covered.">            return CharSegment.of(CharBuffer.wrap(data), data.length &lt; len);</span>
        }

        @Override
        public @Nullable CharBuffer read() throws IORuntimeException {
<span class="fc" id="L116">            char[] buf = IOKit.read0(src, bufSize, IOChecker.endChecker());</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (buf == null) {</span>
<span class="fc" id="L118">                return null;</span>
            }
<span class="fc" id="L120">            return CharBuffer.wrap(buf);</span>
        }

        @Override
        public long skip(long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L125">            IOChecker.checkSkip(len);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L127">                return 0;</span>
            }
            try {
<span class="fc" id="L130">                return skip0(len);</span>
<span class="fc" id="L131">            } catch (Exception e) {</span>
<span class="fc" id="L132">                throw new IORuntimeException(e);</span>
            }
        }

        private long skip0(long len) throws Exception {
<span class="fc" id="L137">            long hasRead = 0;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">            while (hasRead &lt; len) {</span>
<span class="fc" id="L139">                long onceSize = src.skip(len - hasRead);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">                if (onceSize == 0) {</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">                    if (src.read() == -1) {</span>
<span class="fc" id="L142">                        break;</span>
                    } else {
<span class="fc" id="L144">                        hasRead++;</span>
                    }
                }
<span class="fc" id="L147">                hasRead += onceSize;</span>
<span class="fc" id="L148">            }</span>
<span class="fc" id="L149">            return hasRead;</span>
        }

        @Override
        public long readTo(@Nonnull Appendable dst) throws IORuntimeException {
<span class="fc" id="L154">            return readTo(dst, IOChecker.endChecker());</span>
        }

        @Override
        public long readTo(@Nonnull Appendable dst, long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L159">            return readTo(dst, len, IOChecker.endChecker());</span>
        }

        @Override
        public int readTo(char @Nonnull [] dst) throws IORuntimeException {
<span class="fc" id="L164">            return readTo(dst, IOChecker.endChecker());</span>
        }

        @Override
        public int readTo(char @Nonnull [] dst, int off, int len) throws IndexOutOfBoundsException, IORuntimeException {
<span class="fc" id="L169">            return readTo(dst, off, len, IOChecker.endChecker());</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst) throws IORuntimeException {
<span class="fc" id="L174">            return readTo(dst, IOChecker.endChecker());</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst, int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L179">            return readTo(dst, len, IOChecker.endChecker());</span>
        }

        @Override
        public @Nonnull CharSegment available(int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L184">            IOChecker.checkLen(len);</span>
<span class="fc" id="L185">            char[] data = IOKit.read0(src, len, bufSize, IOChecker.availableChecker());</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (data == null) {</span>
<span class="fc" id="L187">                return CharSegment.empty(true);</span>
            }
<span class="fc" id="L189">            return CharSegment.of(CharBuffer.wrap(data), false);</span>
        }

        @Override
        public @Nonnull CharSegment available() throws IORuntimeException {
<span class="fc" id="L194">            char[] data = IOKit.read0(src, bufSize, IOChecker.availableChecker());</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (data == null) {</span>
<span class="fc" id="L196">                return CharSegment.empty(true);</span>
            }
<span class="fc" id="L198">            return CharSegment.of(CharBuffer.wrap(data), false);</span>
        }

        @Override
        public long availableTo(@Nonnull Appendable dst) throws IORuntimeException {
<span class="fc" id="L203">            return readTo(dst, IOChecker.availableChecker());</span>
        }

        @Override
        public long availableTo(@Nonnull Appendable dst, long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L208">            return readTo(dst, len, IOChecker.availableChecker());</span>
        }

        @Override
        public int availableTo(char @Nonnull [] dst) throws IORuntimeException {
<span class="fc" id="L213">            return readTo(dst, IOChecker.availableChecker());</span>
        }

        @Override
        public int availableTo(
            char @Nonnull [] dst, int off, int len
        ) throws IndexOutOfBoundsException, IORuntimeException {
<span class="fc" id="L220">            return readTo(dst, off, len, IOChecker.availableChecker());</span>
        }

        @Override
        public int availableTo(@Nonnull CharBuffer dst) throws IORuntimeException {
<span class="fc" id="L225">            return readTo(dst, IOChecker.availableChecker());</span>
        }

        @Override
        public int availableTo(@Nonnull CharBuffer dst, int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L230">            return readTo(dst, len, IOChecker.availableChecker());</span>
        }

        private long readTo(@Nonnull Appendable dst, ReadChecker readChecker) throws IORuntimeException {
<span class="fc" id="L234">            return IOKit.readTo0(src, dst, bufSize, readChecker);</span>
        }

        private long readTo(
            @Nonnull Appendable dst, long len, ReadChecker readChecker
        ) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L240">            IOChecker.checkLen(len);</span>
<span class="fc" id="L241">            return IOKit.readTo0(src, dst, len, bufSize, readChecker);</span>
        }

        private int readTo(char @Nonnull [] dst, ReadChecker readChecker) throws IORuntimeException {
<span class="fc" id="L245">            return IOKit.readTo0(src, dst, 0, dst.length, readChecker);</span>
        }

        private int readTo(
            char @Nonnull [] dst, int off, int len, ReadChecker readChecker
        ) throws IndexOutOfBoundsException, IORuntimeException {
<span class="fc" id="L251">            IOChecker.checkOffLen(off, len, dst.length);</span>
<span class="fc" id="L252">            return IOKit.readTo0(src, dst, off, len, readChecker);</span>
        }

        private int readTo(@Nonnull CharBuffer dst, ReadChecker readChecker) throws IORuntimeException {
<span class="fc" id="L256">            return IOKit.readTo0(src, dst, dst.remaining(), readChecker);</span>
        }

        private int readTo(
            @Nonnull CharBuffer dst, int len, ReadChecker readChecker
        ) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L262">            IOChecker.checkLen(len);</span>
<span class="fc" id="L263">            return IOKit.readTo0(src, dst, len, readChecker);</span>
        }

        @Override
        public boolean markSupported() {
<span class="fc" id="L268">            return src.markSupported();</span>
        }

        @Override
        public void mark() throws IORuntimeException {
            try {
<span class="fc" id="L274">                src.mark(Integer.MAX_VALUE);</span>
<span class="fc" id="L275">            } catch (Exception e) {</span>
<span class="fc" id="L276">                throw new IORuntimeException(e);</span>
<span class="fc" id="L277">            }</span>
<span class="fc" id="L278">        }</span>

        @Override
        public void reset() throws IORuntimeException {
            try {
<span class="fc" id="L283">                src.reset();</span>
<span class="fc" id="L284">            } catch (Exception e) {</span>
<span class="fc" id="L285">                throw new IORuntimeException(e);</span>
<span class="fc" id="L286">            }</span>
<span class="fc" id="L287">        }</span>

        @Override
        public void close() throws IORuntimeException {
            try {
<span class="fc" id="L292">                src.close();</span>
<span class="fc" id="L293">            } catch (Exception e) {</span>
<span class="fc" id="L294">                throw new IORuntimeException(e);</span>
<span class="fc" id="L295">            }</span>
<span class="fc" id="L296">        }</span>

        @Override
        public @Nonnull Reader asReader() {
<span class="fc" id="L300">            return src;</span>
        }
    }

    private static abstract class InMemoryReader implements CharReader {

        @Override
        public @Nonnull CharSegment available(int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L308">            return read(len);</span>
        }

        @Override
        public long availableTo(@Nonnull Appendable dst) throws IORuntimeException {
<span class="fc" id="L313">            return readTo(dst);</span>
        }

        @Override
        public long availableTo(
            @Nonnull Appendable dst, long len
        ) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L320">            return readTo(dst, len);</span>
        }

        @Override
        public int availableTo(char @Nonnull [] dst) throws IORuntimeException {
<span class="fc" id="L325">            return readTo(dst);</span>
        }

        @Override
        public int availableTo(
            char @Nonnull [] dst, int off, int len
        ) throws IndexOutOfBoundsException, IORuntimeException {
<span class="fc" id="L332">            return readTo(dst, off, len);</span>
        }

        @Override
        public int availableTo(@Nonnull CharBuffer dst) throws IORuntimeException {
<span class="fc" id="L337">            return readTo(dst);</span>
        }

        @Override
        public int availableTo(@Nonnull CharBuffer dst, int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L342">            return readTo(dst, len);</span>
        }
    }

    private static final class CharArrayReader extends InMemoryReader {

        private final char @Nonnull [] src;
        private int pos;
        private final int end;
        private int mark;

<span class="fc" id="L353">        private CharArrayReader(char @Nonnull [] src, int offset, int length) {</span>
<span class="fc" id="L354">            this.src = src;</span>
<span class="fc" id="L355">            this.pos = offset;</span>
<span class="fc" id="L356">            this.end = offset + length;</span>
<span class="fc" id="L357">            this.mark = pos;</span>
<span class="fc" id="L358">        }</span>

        @Override
        public int ready() {
<span class="fc" id="L362">            return end - pos;</span>
        }

        @Override
        public @Nonnull CharSegment read(int len) throws IllegalArgumentException {
<span class="fc" id="L367">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L369">                return CharSegment.empty(false);</span>
            }
<span class="fc bfc" id="L371" title="All 2 branches covered.">            if (pos == end) {</span>
<span class="fc" id="L372">                return CharSegment.empty(true);</span>
            }
<span class="fc" id="L374">            int remaining = end - pos;</span>
<span class="fc" id="L375">            int actualLen = Math.min(remaining, len);</span>
<span class="fc" id="L376">            CharBuffer data = CharBuffer.wrap(src, pos, actualLen).slice();</span>
<span class="fc" id="L377">            pos += actualLen;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            return CharSegment.of(data, remaining &lt;= len);</span>
        }

        @Override
        public @Nullable CharBuffer read() throws IORuntimeException {
<span class="fc bfc" id="L383" title="All 2 branches covered.">            if (pos &gt;= end) {</span>
<span class="fc" id="L384">                return null;</span>
            }
<span class="fc" id="L386">            CharBuffer ret = CharBuffer.wrap(src, pos, end - pos);</span>
<span class="fc" id="L387">            pos = end;</span>
<span class="fc" id="L388">            return ret;</span>
        }

        @Override
        public long skip(long len) throws IllegalArgumentException {
<span class="fc" id="L393">            IOChecker.checkSkip(len);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L395">                return 0;</span>
            }
<span class="fc bfc" id="L397" title="All 2 branches covered.">            if (pos == end) {</span>
<span class="fc" id="L398">                return 0;</span>
            }
<span class="fc" id="L400">            int remaining = end - pos;</span>
<span class="fc" id="L401">            int skipped = (int) Math.min(remaining, len);</span>
<span class="fc" id="L402">            pos += skipped;</span>
<span class="fc" id="L403">            return skipped;</span>
        }

        @Override
        public long readTo(@Nonnull Appendable dst) throws IORuntimeException {
<span class="fc bfc" id="L408" title="All 2 branches covered.">            if (end == pos) {</span>
<span class="fc" id="L409">                return -1;</span>
            }
            try {
<span class="fc" id="L412">                int remaining = end - pos;</span>
<span class="fc" id="L413">                IOKit.write(dst, src, pos, remaining);</span>
<span class="fc" id="L414">                pos += remaining;</span>
<span class="fc" id="L415">                return remaining;</span>
<span class="fc" id="L416">            } catch (Exception e) {</span>
<span class="fc" id="L417">                throw new IORuntimeException(e);</span>
            }
        }

        @Override
        public long readTo(@Nonnull Appendable dst, long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L423">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L425">                return 0;</span>
            }
<span class="fc bfc" id="L427" title="All 2 branches covered.">            if (end == pos) {</span>
<span class="fc" id="L428">                return -1;</span>
            }
            try {
<span class="fc" id="L431">                int remaining = end - pos;</span>
<span class="fc" id="L432">                int actualLen = (int) Math.min(remaining, len);</span>
<span class="fc" id="L433">                IOKit.write(dst, src, pos, actualLen);</span>
<span class="fc" id="L434">                pos += actualLen;</span>
<span class="fc" id="L435">                return actualLen;</span>
<span class="fc" id="L436">            } catch (Exception e) {</span>
<span class="fc" id="L437">                throw new IORuntimeException(e);</span>
            }
        }

        @Override
        public int readTo(char @Nonnull [] dst) {
<span class="fc" id="L443">            return readTo0(dst, 0, dst.length);</span>
        }

        @Override
        public int readTo(char @Nonnull [] dst, int off, int len) throws IndexOutOfBoundsException {
<span class="fc" id="L448">            IOChecker.checkOffLen(off, len, dst.length);</span>
<span class="fc" id="L449">            return readTo0(dst, off, len);</span>
        }

        private int readTo0(char @Nonnull [] dst, int off, int len) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L454">                return 0;</span>
            }
<span class="fc bfc" id="L456" title="All 2 branches covered.">            if (end == pos) {</span>
<span class="fc" id="L457">                return -1;</span>
            }
<span class="fc" id="L459">            int remaining = end - pos;</span>
<span class="fc" id="L460">            int copySize = Math.min(remaining, len);</span>
<span class="fc" id="L461">            System.arraycopy(src, pos, dst, off, copySize);</span>
<span class="fc" id="L462">            pos += copySize;</span>
<span class="fc" id="L463">            return copySize;</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst) throws IORuntimeException {
<span class="fc bfc" id="L468" title="All 2 branches covered.">            if (dst.remaining() == 0) {</span>
<span class="fc" id="L469">                return 0;</span>
            }
<span class="fc bfc" id="L471" title="All 2 branches covered.">            if (pos == end) {</span>
<span class="fc" id="L472">                return -1;</span>
            }
<span class="fc" id="L474">            int remaining = end - pos;</span>
<span class="fc" id="L475">            int putSize = Math.min(remaining, dst.remaining());</span>
<span class="fc" id="L476">            return putTo0(dst, putSize);</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst, int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L481">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L483">                return 0;</span>
            }
<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (dst.remaining() == 0) {</span>
<span class="fc" id="L486">                return 0;</span>
            }
<span class="fc bfc" id="L488" title="All 2 branches covered.">            if (pos == end) {</span>
<span class="fc" id="L489">                return -1;</span>
            }
<span class="fc" id="L491">            int remaining = end - pos;</span>
<span class="fc" id="L492">            int putSize = MathKit.min(remaining, dst.remaining(), len);</span>
<span class="fc" id="L493">            return putTo0(dst, putSize);</span>
        }

        @Override
        public @Nonnull CharSegment available() throws IORuntimeException {
<span class="fc" id="L498">            return read(end - pos);</span>
        }

        private int putTo0(@Nonnull CharBuffer dst, int putSize) throws IORuntimeException {
            try {
<span class="fc" id="L503">                dst.put(src, pos, putSize);</span>
<span class="fc" id="L504">                pos += putSize;</span>
<span class="fc" id="L505">                return putSize;</span>
<span class="fc" id="L506">            } catch (Exception e) {</span>
<span class="fc" id="L507">                throw new IORuntimeException(e);</span>
            }
        }

        @Override
        public boolean markSupported() {
<span class="fc" id="L513">            return true;</span>
        }

        @Override
        public void mark() {
<span class="fc" id="L518">            mark = pos;</span>
<span class="fc" id="L519">        }</span>

        @Override
        public void reset() {
<span class="fc" id="L523">            pos = mark;</span>
<span class="fc" id="L524">        }</span>

        @Override
        public void close() {
<span class="fc" id="L528">        }</span>
    }

    private static final class CharSequenceReader extends InMemoryReader {

        private final @Nonnull CharSequence src;
        private final int endPos;
        private int pos;
        private int mark;

<span class="fc" id="L538">        private CharSequenceReader(@Nonnull CharSequence src, int start, int end) {</span>
<span class="fc" id="L539">            this.src = src;</span>
<span class="fc" id="L540">            this.pos = start;</span>
<span class="fc" id="L541">            this.endPos = end;</span>
<span class="fc" id="L542">            this.mark = pos;</span>
<span class="fc" id="L543">        }</span>

        @Override
        public int ready() {
<span class="fc" id="L547">            return endPos - pos;</span>
        }

        @Override
        public @Nonnull CharSegment read(int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L552">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L554">                return CharSegment.empty(false);</span>
            }
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (pos == endPos) {</span>
<span class="fc" id="L557">                return CharSegment.empty(true);</span>
            }
<span class="fc" id="L559">            int remaining = endPos - pos;</span>
<span class="fc" id="L560">            int actualLen = Math.min(remaining, len);</span>
<span class="fc" id="L561">            CharBuffer data = CharBuffer.wrap(src, pos, pos + actualLen).slice();</span>
<span class="fc" id="L562">            pos += actualLen;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">            return CharSegment.of(data, remaining &lt;= len);</span>
        }

        @Override
        public @Nullable CharBuffer read() throws IORuntimeException {
<span class="fc bfc" id="L568" title="All 2 branches covered.">            if (pos &gt;= endPos) {</span>
<span class="fc" id="L569">                return null;</span>
            }
<span class="fc" id="L571">            CharBuffer ret = CharBuffer.wrap(src, pos, endPos);</span>
<span class="fc" id="L572">            pos = endPos;</span>
<span class="fc" id="L573">            return ret;</span>
        }

        @Override
        public long skip(long len) throws IllegalArgumentException {
<span class="fc" id="L578">            IOChecker.checkSkip(len);</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L580">                return 0;</span>
            }
<span class="fc bfc" id="L582" title="All 2 branches covered.">            if (pos == endPos) {</span>
<span class="fc" id="L583">                return 0;</span>
            }
<span class="fc" id="L585">            int remaining = endPos - pos;</span>
<span class="fc" id="L586">            int skipped = (int) Math.min(remaining, len);</span>
<span class="fc" id="L587">            pos += skipped;</span>
<span class="fc" id="L588">            return skipped;</span>
        }

        @Override
        public long readTo(@Nonnull Appendable dst) throws IORuntimeException {
<span class="fc bfc" id="L593" title="All 2 branches covered.">            if (endPos == pos) {</span>
<span class="fc" id="L594">                return -1;</span>
            }
            try {
<span class="fc" id="L597">                int remaining = endPos - pos;</span>
<span class="fc" id="L598">                dst.append(src, pos, pos + remaining);</span>
<span class="fc" id="L599">                pos += remaining;</span>
<span class="fc" id="L600">                return remaining;</span>
<span class="fc" id="L601">            } catch (Exception e) {</span>
<span class="fc" id="L602">                throw new IORuntimeException(e);</span>
            }
        }

        @Override
        public long readTo(@Nonnull Appendable dst, long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L608">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L610">                return 0;</span>
            }
<span class="fc bfc" id="L612" title="All 2 branches covered.">            if (endPos == pos) {</span>
<span class="fc" id="L613">                return -1;</span>
            }
            try {
<span class="fc" id="L616">                int remaining = endPos - pos;</span>
<span class="fc" id="L617">                int actualLen = (int) Math.min(remaining, len);</span>
<span class="fc" id="L618">                dst.append(src, pos, pos + actualLen);</span>
<span class="fc" id="L619">                pos += actualLen;</span>
<span class="fc" id="L620">                return actualLen;</span>
<span class="fc" id="L621">            } catch (Exception e) {</span>
<span class="fc" id="L622">                throw new IORuntimeException(e);</span>
            }
        }

        @Override
        public int readTo(char @Nonnull [] dst) {
<span class="fc" id="L628">            return readTo0(dst, 0, dst.length);</span>
        }

        @Override
        public int readTo(char @Nonnull [] dst, int off, int len) throws IndexOutOfBoundsException {
<span class="fc" id="L633">            IOChecker.checkOffLen(off, len, dst.length);</span>
<span class="fc" id="L634">            return readTo0(dst, off, len);</span>
        }

        private int readTo0(char @Nonnull [] dst, int off, int len) {
<span class="fc bfc" id="L638" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L639">                return 0;</span>
            }
<span class="fc bfc" id="L641" title="All 2 branches covered.">            if (endPos == pos) {</span>
<span class="fc" id="L642">                return -1;</span>
            }
<span class="fc" id="L644">            int remaining = endPos - pos;</span>
<span class="fc" id="L645">            int copySize = Math.min(remaining, len);</span>
<span class="fc" id="L646">            StringKit.charsCopy(src, pos, dst, off, copySize);</span>
<span class="fc" id="L647">            pos += copySize;</span>
<span class="fc" id="L648">            return copySize;</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst) throws IORuntimeException {
<span class="fc bfc" id="L653" title="All 2 branches covered.">            if (dst.remaining() == 0) {</span>
<span class="fc" id="L654">                return 0;</span>
            }
<span class="fc bfc" id="L656" title="All 2 branches covered.">            if (pos == endPos) {</span>
<span class="fc" id="L657">                return -1;</span>
            }
<span class="fc" id="L659">            int remaining = endPos - pos;</span>
<span class="fc" id="L660">            int putSize = Math.min(remaining, dst.remaining());</span>
<span class="fc" id="L661">            return putTo0(dst, putSize);</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst, int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L666">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L668">                return 0;</span>
            }
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (dst.remaining() == 0) {</span>
<span class="fc" id="L671">                return 0;</span>
            }
<span class="fc bfc" id="L673" title="All 2 branches covered.">            if (pos == endPos) {</span>
<span class="fc" id="L674">                return -1;</span>
            }
<span class="fc" id="L676">            int remaining = endPos - pos;</span>
<span class="fc" id="L677">            int putSize = MathKit.min(remaining, dst.remaining(), len);</span>
<span class="fc" id="L678">            return putTo0(dst, putSize);</span>
        }

        @Override
        public @Nonnull CharSegment available() throws IORuntimeException {
<span class="fc" id="L683">            return read(endPos - pos);</span>
        }

        private int putTo0(@Nonnull CharBuffer dst, int putSize) throws IORuntimeException {
            try {
<span class="fc" id="L688">                dst.put(CharBuffer.wrap(src, pos, pos + putSize));</span>
<span class="fc" id="L689">                pos += putSize;</span>
<span class="fc" id="L690">                return putSize;</span>
<span class="fc" id="L691">            } catch (Exception e) {</span>
<span class="fc" id="L692">                throw new IORuntimeException(e);</span>
            }
        }

        @Override
        public boolean markSupported() {
<span class="fc" id="L698">            return true;</span>
        }

        @Override
        public void mark() {
<span class="fc" id="L703">            mark = pos;</span>
<span class="fc" id="L704">        }</span>

        @Override
        public void reset() {
<span class="fc" id="L708">            pos = mark;</span>
<span class="fc" id="L709">        }</span>

        @Override
        public void close() {
<span class="fc" id="L713">        }</span>
    }

    private static final class CharBufferReader extends InMemoryReader {

        private final @Nonnull CharBuffer src;

<span class="fc" id="L720">        private CharBufferReader(@Nonnull CharBuffer src) {</span>
<span class="fc" id="L721">            this.src = src;</span>
<span class="fc" id="L722">        }</span>

        @Override
        public int ready() {
<span class="fc" id="L726">            return src.remaining();</span>
        }

        @Override
        public @Nonnull CharSegment read(int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L731">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L733">                return CharSegment.empty(false);</span>
            }
<span class="fc bfc" id="L735" title="All 2 branches covered.">            if (!src.hasRemaining()) {</span>
<span class="fc" id="L736">                return CharSegment.empty(true);</span>
            }
<span class="fc" id="L738">            int pos = src.position();</span>
<span class="fc" id="L739">            int limit = src.limit();</span>
<span class="fc" id="L740">            int newPos = Math.min(pos + len, limit);</span>
<span class="fc" id="L741">            src.limit(newPos);</span>
<span class="fc" id="L742">            CharBuffer data = src.slice();</span>
<span class="fc" id="L743">            src.position(newPos);</span>
<span class="fc" id="L744">            src.limit(limit);</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">            return CharSegment.of(data, newPos &gt;= limit);</span>
        }

        @Override
        public @Nullable CharBuffer read() throws IORuntimeException {
<span class="fc bfc" id="L750" title="All 2 branches covered.">            if (!src.hasRemaining()) {</span>
<span class="fc" id="L751">                return null;</span>
            }
<span class="fc" id="L753">            CharBuffer ret = src.slice();</span>
<span class="fc" id="L754">            src.position(src.limit());</span>
<span class="fc" id="L755">            return ret;</span>
        }

        @Override
        public long skip(long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L760">            IOChecker.checkSkip(len);</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L762">                return 0;</span>
            }
<span class="fc bfc" id="L764" title="All 2 branches covered.">            if (!src.hasRemaining()) {</span>
<span class="fc" id="L765">                return 0;</span>
            }
<span class="fc" id="L767">            int pos = src.position();</span>
<span class="fc" id="L768">            int newPos = (int) Math.min(pos + len, src.limit());</span>
<span class="fc" id="L769">            src.position(newPos);</span>
<span class="fc" id="L770">            return newPos - pos;</span>
        }

        @Override
        public long readTo(@Nonnull Appendable dst) throws IORuntimeException {
<span class="fc" id="L775">            return BufferKit.readTo(src, dst);</span>
        }

        @Override
        public long readTo(@Nonnull Appendable dst, long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L780">            IOChecker.checkLen(len);</span>
<span class="fc" id="L781">            int actualLen = (int) Math.min(Integer.MAX_VALUE, len);</span>
<span class="fc" id="L782">            return BufferKit.readTo0(src, dst, actualLen);</span>
        }

        @Override
        public int readTo(char @Nonnull [] dst) throws IORuntimeException {
<span class="fc" id="L787">            return BufferKit.readTo(src, dst);</span>
        }

        @Override
        public int readTo(char @Nonnull [] dst, int off, int len) throws IndexOutOfBoundsException, IORuntimeException {
<span class="fc" id="L792">            return BufferKit.readTo(src, dst, off, len);</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst) throws IORuntimeException {
<span class="fc" id="L797">            return BufferKit.readTo(src, dst);</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst, int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L802">            return BufferKit.readTo(src, dst, len);</span>
        }

        @Override
        public @Nonnull CharSegment available() throws IORuntimeException {
<span class="fc" id="L807">            return read(src.remaining());</span>
        }

        @Override
        public boolean markSupported() {
<span class="fc" id="L812">            return true;</span>
        }

        @Override
        public void mark() throws IORuntimeException {
<span class="fc" id="L817">            src.mark();</span>
<span class="fc" id="L818">        }</span>

        @Override
        public void reset() throws IORuntimeException {
            try {
<span class="fc" id="L823">                src.reset();</span>
<span class="fc" id="L824">            } catch (Exception e) {</span>
<span class="fc" id="L825">                throw new IORuntimeException(e);</span>
<span class="fc" id="L826">            }</span>
<span class="fc" id="L827">        }</span>

        @Override
        public void close() throws IORuntimeException {
<span class="fc" id="L831">        }</span>
    }

    private static final class LimitedReader implements CharReader {

        private final @Nonnull CharReader src;
        private final long limit;

<span class="fc" id="L839">        private long pos = 0;</span>
<span class="fc" id="L840">        private long mark = 0;</span>

<span class="fc" id="L842">        private LimitedReader(@Nonnull CharReader src, long limit) {</span>
<span class="fc" id="L843">            this.src = src;</span>
<span class="fc" id="L844">            this.limit = limit;</span>
<span class="fc" id="L845">        }</span>

        @Override
        public int ready() throws IORuntimeException {
<span class="fc" id="L849">            return Math.min(src.ready(), MathKit.intValue(limit - pos));</span>
        }

        @Override
        public @Nonnull CharSegment read(int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L854">            return read(len, false);</span>
        }

        @Override
        public @Nullable CharBuffer read() throws IORuntimeException {
<span class="fc bfc" id="L859" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L860">                return null;</span>
            }
<span class="fc" id="L862">            int len = MathKit.intValue(limit - pos);</span>
<span class="fc" id="L863">            return read(len).data();</span>
        }

        @Override
        public long skip(long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L868">            IOChecker.checkSkip(len);</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L870">                return 0;</span>
            }
<span class="fc bfc" id="L872" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L873">                return 0;</span>
            }
<span class="fc" id="L875">            int actualLen = (int) Math.min(len, limit - pos);</span>
<span class="fc" id="L876">            long skipped = src.skip(actualLen);</span>
<span class="fc" id="L877">            pos += skipped;</span>
<span class="fc" id="L878">            return skipped;</span>
        }

        @Override
        public long readTo(@Nonnull Appendable dst) throws IORuntimeException {
<span class="fc bfc" id="L883" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L884">                return -1;</span>
            }
<span class="fc" id="L886">            long readSize = src.readTo(dst, limit - pos);</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">            if (readSize &lt; 0) {</span>
<span class="fc" id="L888">                return readSize;</span>
            }
<span class="fc" id="L890">            pos += readSize;</span>
<span class="fc" id="L891">            return readSize;</span>
        }

        @Override
        public long readTo(@Nonnull Appendable dst, long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L896">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L898">                return 0;</span>
            }
<span class="fc bfc" id="L900" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L901">                return -1;</span>
            }
<span class="fc" id="L903">            int actualLen = (int) Math.min(len, limit - pos);</span>
<span class="fc" id="L904">            long readSize = src.readTo(dst, actualLen);</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">            if (readSize &lt; 0) {</span>
<span class="fc" id="L906">                return readSize;</span>
            }
<span class="fc" id="L908">            pos += readSize;</span>
<span class="fc" id="L909">            return readSize;</span>
        }

        @Override
        public int readTo(char @Nonnull [] dst) throws IORuntimeException {
<span class="fc" id="L914">            return readTo(dst, 0, dst.length);</span>
        }

        @Override
        public int readTo(
            char @Nonnull [] dst, int off, int len
        ) throws IndexOutOfBoundsException, IORuntimeException {
<span class="fc" id="L921">            IOChecker.checkOffLen(off, len, dst.length);</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L923">                return 0;</span>
            }
<span class="fc bfc" id="L925" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L926">                return -1;</span>
            }
<span class="fc" id="L928">            int actualLen = (int) Math.min(len, limit - pos);</span>
<span class="fc" id="L929">            int readSize = src.readTo(dst, off, actualLen);</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">            if (readSize &lt; 0) {</span>
<span class="fc" id="L931">                return readSize;</span>
            }
<span class="fc" id="L933">            pos += readSize;</span>
<span class="fc" id="L934">            return readSize;</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst) throws IORuntimeException {
<span class="fc" id="L939">            return readTo(dst, dst.remaining());</span>
        }

        @Override
        public int readTo(@Nonnull CharBuffer dst, int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L944">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L946">                return 0;</span>
            }
<span class="fc bfc" id="L948" title="All 2 branches covered.">            if (!dst.hasRemaining()) {</span>
<span class="fc" id="L949">                return 0;</span>
            }
<span class="fc bfc" id="L951" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L952">                return -1;</span>
            }
<span class="fc" id="L954">            int actualLen = (int) Math.min(len, limit - pos);</span>
<span class="fc" id="L955">            actualLen = Math.min(actualLen, dst.remaining());</span>
<span class="fc" id="L956">            int readSize = src.readTo(dst, actualLen);</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">            if (readSize &lt; 0) {</span>
<span class="fc" id="L958">                return readSize;</span>
            }
<span class="fc" id="L960">            pos += readSize;</span>
<span class="fc" id="L961">            return readSize;</span>
        }

        @Override
        public @Nonnull CharSegment available(int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L966">            return read(len, true);</span>
        }

        @Override
        public @Nonnull CharSegment available() throws IORuntimeException {
<span class="fc" id="L971">            return available(MathKit.intValue(limit - pos));</span>
        }

        @Override
        public long availableTo(@Nonnull Appendable dst) throws IORuntimeException {
<span class="fc bfc" id="L976" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L977">                return -1;</span>
            }
<span class="fc" id="L979">            long readSize = src.availableTo(dst, limit - pos);</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">            if (readSize &lt;= 0) {</span>
<span class="fc" id="L981">                return readSize;</span>
            }
<span class="fc" id="L983">            pos += readSize;</span>
<span class="fc" id="L984">            return readSize;</span>
        }

        @Override
        public long availableTo(@Nonnull Appendable dst, long len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L989">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L991">                return 0;</span>
            }
<span class="fc bfc" id="L993" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L994">                return -1;</span>
            }
<span class="fc" id="L996">            int actualLen = (int) Math.min(len, limit - pos);</span>
<span class="fc" id="L997">            long readSize = src.availableTo(dst, actualLen);</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">            if (readSize &lt;= 0) {</span>
<span class="fc" id="L999">                return readSize;</span>
            }
<span class="fc" id="L1001">            pos += readSize;</span>
<span class="fc" id="L1002">            return readSize;</span>
        }

        @Override
        public int availableTo(char @Nonnull [] dst) throws IORuntimeException {
<span class="fc" id="L1007">            return availableTo(dst, 0, dst.length);</span>
        }

        @Override
        public int availableTo(
            char @Nonnull [] dst, int off, int len
        ) throws IndexOutOfBoundsException, IORuntimeException {
<span class="fc" id="L1014">            IOChecker.checkOffLen(off, len, dst.length);</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L1016">                return 0;</span>
            }
<span class="fc bfc" id="L1018" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L1019">                return -1;</span>
            }
<span class="fc" id="L1021">            int actualLen = (int) Math.min(len, limit - pos);</span>
<span class="fc" id="L1022">            int readSize = src.availableTo(dst, off, actualLen);</span>
<span class="fc bfc" id="L1023" title="All 2 branches covered.">            if (readSize &lt;= 0) {</span>
<span class="fc" id="L1024">                return readSize;</span>
            }
<span class="fc" id="L1026">            pos += readSize;</span>
<span class="fc" id="L1027">            return readSize;</span>
        }

        @Override
        public int availableTo(@Nonnull CharBuffer dst) throws IORuntimeException {
<span class="fc" id="L1032">            return availableTo(dst, dst.remaining());</span>
        }

        @Override
        public int availableTo(@Nonnull CharBuffer dst, int len) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L1037">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L1039">                return 0;</span>
            }
<span class="fc bfc" id="L1041" title="All 2 branches covered.">            if (!dst.hasRemaining()) {</span>
<span class="fc" id="L1042">                return 0;</span>
            }
<span class="fc bfc" id="L1044" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L1045">                return -1;</span>
            }
<span class="fc" id="L1047">            int actualLen = (int) Math.min(len, limit - pos);</span>
<span class="fc" id="L1048">            actualLen = Math.min(actualLen, dst.remaining());</span>
<span class="fc" id="L1049">            int readSize = src.availableTo(dst, actualLen);</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">            if (readSize &lt;= 0) {</span>
<span class="fc" id="L1051">                return readSize;</span>
            }
<span class="fc" id="L1053">            pos += readSize;</span>
<span class="fc" id="L1054">            return readSize;</span>
        }

        private @Nonnull CharSegment read(int len, boolean available) throws IllegalArgumentException, IORuntimeException {
<span class="fc" id="L1058">            IOChecker.checkLen(len);</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L1060">                return CharSegment.empty(false);</span>
            }
<span class="fc bfc" id="L1062" title="All 2 branches covered.">            if (pos &gt;= limit) {</span>
<span class="fc" id="L1063">                return CharSegment.empty(true);</span>
            }
<span class="fc" id="L1065">            int maxLen = (int) Math.min(len, limit - pos);</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">            CharSegment segment = available ? src.available(maxLen) : src.read(maxLen);</span>
<span class="fc" id="L1067">            pos += segment.data().remaining();</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">            if (!segment.end()) {</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">                if (pos &gt;= limit) {</span>
<span class="fc" id="L1070">                    return newSeg(segment.data(), true);</span>
                }
            }
<span class="fc" id="L1073">            return segment;</span>
        }

        @Override
        public boolean markSupported() {
<span class="fc" id="L1078">            return src.markSupported();</span>
        }

        @Override
        public void mark() throws IORuntimeException {
<span class="fc" id="L1083">            src.mark();</span>
<span class="fc" id="L1084">            mark = pos;</span>
<span class="fc" id="L1085">        }</span>

        @Override
        public void reset() throws IORuntimeException {
<span class="fc" id="L1089">            src.reset();</span>
<span class="fc" id="L1090">            pos = mark;</span>
<span class="fc" id="L1091">        }</span>

        @Override
        public void close() throws IORuntimeException {
<span class="fc" id="L1095">            src.close();</span>
<span class="fc" id="L1096">        }</span>
    }

    static final class AsReader extends DoReadReader {

        private final @Nonnull CharReader in;
        private char[] oneChar;

<span class="fc" id="L1104">        private AsReader(@Nonnull CharReader in) {</span>
<span class="fc" id="L1105">            this.in = in;</span>
<span class="fc" id="L1106">        }</span>

        @Override
        public int read() throws IOException {
            try {
<span class="fc bfc" id="L1111" title="All 2 branches covered.">                if (oneChar == null) {</span>
<span class="fc" id="L1112">                    oneChar = new char[1];</span>
                }
<span class="fc" id="L1114">                int ret = in.readTo(oneChar);</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">                return ret &lt; 0 ? -1 : oneChar[0];</span>
<span class="fc" id="L1116">            } catch (Exception e) {</span>
<span class="fc" id="L1117">                throw new IOException(e);</span>
            }
        }

        @Override
        protected int doRead(char @Nonnull [] b, int off, int len) throws IOException {
            try {
<span class="fc" id="L1124">                return in.readTo(b, off, len);</span>
<span class="fc" id="L1125">            } catch (Exception e) {</span>
<span class="fc" id="L1126">                throw new IOException(e);</span>
            }
        }

        @Override
        public long skip(long n) throws IllegalArgumentException, IOException {
            try {
<span class="fc" id="L1133">                return in.skip(n);</span>
<span class="fc" id="L1134">            } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L1135">                throw e;</span>
<span class="fc" id="L1136">            } catch (Exception e) {</span>
<span class="fc" id="L1137">                throw new IOException(e);</span>
            }
        }

        @Override
        public boolean markSupported() {
<span class="fc" id="L1143">            return in.markSupported();</span>
        }

        @Override
        public void mark(int readAheadLimit) throws IOException {
            try {
<span class="fc" id="L1149">                in.mark();</span>
<span class="fc" id="L1150">            } catch (Exception e) {</span>
<span class="fc" id="L1151">                throw new IOException(e);</span>
<span class="fc" id="L1152">            }</span>
<span class="fc" id="L1153">        }</span>

        @Override
        public void reset() throws IOException {
            try {
<span class="fc" id="L1158">                in.reset();</span>
<span class="fc" id="L1159">            } catch (Exception e) {</span>
<span class="fc" id="L1160">                throw new IOException(e);</span>
<span class="fc" id="L1161">            }</span>
<span class="fc" id="L1162">        }</span>

        @Override
        public void close() throws IOException {
            try {
<span class="fc" id="L1167">                in.close();</span>
<span class="fc" id="L1168">            } catch (Exception e) {</span>
<span class="fc" id="L1169">                throw new IOException(e);</span>
<span class="fc" id="L1170">            }</span>
<span class="fc" id="L1171">        }</span>
    }

    private CharReaderBack() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>