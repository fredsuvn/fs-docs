<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeKit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.runtime.reflect</a> &gt; <span class="el_source">TypeKit.java</span></div><h1>TypeKit.java</h1><pre class="source lang-java linenums">package space.sunqian.common.runtime.reflect;

import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.annotations.OutParam;
import space.sunqian.annotations.RetainedParam;
import space.sunqian.common.Fs;
import space.sunqian.common.collect.ArrayKit;
import space.sunqian.common.collect.MapKit;

import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Utilities for {@link Type}.
 *
 * @author sunqian
 */
public class TypeKit {

    /**
     * Returns {@code true} if the given type is a {@link Class}, {@code false} otherwise.
     *
     * @param type the given type
     * @return {@code true} if the given type is a {@link Class}, {@code false} otherwise
     */
    public static boolean isClass(@Nonnull Type type) {
<span class="fc" id="L41">        return type instanceof Class&lt;?&gt;;</span>
    }

    /**
     * Returns {@code true} if the given type is a {@link ParameterizedType}, {@code false} otherwise.
     *
     * @param type the given type
     * @return {@code true} if the given type is a {@link ParameterizedType}, {@code false} otherwise
     */
    public static boolean isParameterized(@Nonnull Type type) {
<span class="fc" id="L51">        return type instanceof ParameterizedType;</span>
    }

    /**
     * Returns {@code true} if the given type is a {@link WildcardType}, {@code false} otherwise.
     *
     * @param type the given type
     * @return {@code true} if the given type is a {@link WildcardType}, {@code false} otherwise
     */
    public static boolean isWildcard(@Nonnull Type type) {
<span class="fc" id="L61">        return type instanceof WildcardType;</span>
    }

    /**
     * Returns {@code true} if the given type is a {@link TypeVariable}, {@code false} otherwise.
     *
     * @param type the given type
     * @return {@code true} if the given type is a {@link TypeVariable}, {@code false} otherwise
     */
    public static boolean isTypeVariable(@Nonnull Type type) {
<span class="fc" id="L71">        return type instanceof TypeVariable&lt;?&gt;;</span>
    }

    /**
     * Returns {@code true} if the given type is a {@link GenericArrayType}, {@code false} otherwise.
     *
     * @param type the given type
     * @return {@code true} if the given type is a {@link GenericArrayType}, {@code false} otherwise
     */
    public static boolean isGenericArray(@Nonnull Type type) {
<span class="fc" id="L81">        return type instanceof GenericArrayType;</span>
    }

    /**
     * Returns whether the given type is an array type (array {@link Class} or {@link GenericArrayType}).
     *
     * @param type the given type
     * @return whether the given type is an array type (array {@link Class} or {@link GenericArrayType})
     */
    public static boolean isArray(@Nonnull Type type) {
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (isClass(type)) {</span>
<span class="fc" id="L92">            return ((Class&lt;?&gt;) type).isArray();</span>
        }
<span class="fc" id="L94">        return isGenericArray(type);</span>
    }

    /**
     * Returns the last name of the given type. The last name is sub-string after last dot(.) For example: the last name
     * of {@code java.lang.String} is {@code String}.
     *
     * @param type the given type
     * @return the last name of given type
     */
    public static @Nonnull String getLastName(@Nonnull Type type) {
<span class="fc" id="L105">        String className = type.getTypeName();</span>
<span class="fc" id="L106">        return getLastName(className);</span>
    }

    private static @Nonnull String getLastName(@Nonnull String typeName) {
<span class="fc" id="L110">        int index = typeName.lastIndexOf('.');</span>
<span class="fc" id="L111">        return typeName.substring(index + 1);</span>
    }

    /**
     * Returns the raw class of the given type. The given type must be a {@link Class} or {@link ParameterizedType}.
     * This method returns the given type itself if it is a {@link Class}, or {@link ParameterizedType#getRawType()} if
     * it is a {@link ParameterizedType}. Returns {@code null} if the given type neither be {@link Class} nor
     * {@link ParameterizedType}, or the raw type is not a {@link Class}.
     *
     * @param type the given type
     * @return the raw class of given type, or {@code null} if the given type neither be {@link Class} nor
     * {@link ParameterizedType}, or the raw type is not a {@link Class}
     */
    public static @Nullable Class&lt;?&gt; getRawClass(@Nonnull Type type) {
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (isClass(type)) {</span>
<span class="fc" id="L126">            return (Class&lt;?&gt;) type;</span>
        }
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (isParameterized(type)) {</span>
<span class="fc" id="L129">            Type rawType = ((ParameterizedType) type).getRawType();</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            return isClass(rawType) ? (Class&lt;?&gt;) rawType : null;</span>
        }
<span class="fc" id="L132">        return null;</span>
    }

    /**
     * Returns the first upper bound type of the given wildcard type ({@code ? extends}). Note that if no upper bound is
     * explicitly declared, returns {@code Object.class}.
     *
     * @param type the given wildcard type
     * @return the first upper bound type of the given wildcard type
     */
    public static @Nonnull Type getUpperBound(@Nonnull WildcardType type) {
<span class="fc" id="L143">        Type[] upperBounds = type.getUpperBounds();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (ArrayKit.isNotEmpty(upperBounds)) {</span>
<span class="fc" id="L145">            return upperBounds[0];</span>
        }
<span class="fc" id="L147">        return Object.class;</span>
    }

    /**
     * Returns the first lower bound type of the given wildcard type ({@code ? super}). If given type has no lower
     * bound, returns {@code null}.
     *
     * @param type the given wildcard type
     * @return the first lower bound type of the given wildcard type or {@code null}
     */
    public static @Nullable Type getLowerBound(@Nonnull WildcardType type) {
<span class="fc" id="L158">        Type[] lowerBounds = type.getLowerBounds();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (ArrayKit.isNotEmpty(lowerBounds)) {</span>
<span class="fc" id="L160">            return lowerBounds[0];</span>
        }
<span class="fc" id="L162">        return null;</span>
    }

    /**
     * Returns the first bound type of the given type variable ({@code T extends}). Note that if no upper bound is
     * explicitly declared, returns {@code Object.class}.
     *
     * @param type the given type variable
     * @return the first upper bound type of the given type variable
     */
    public static @Nonnull Type getFirstBound(@Nonnull TypeVariable&lt;?&gt; type) {
<span class="fc" id="L173">        Type[] bounds = type.getBounds();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (ArrayKit.isNotEmpty(bounds)) {</span>
<span class="fc" id="L175">            return bounds[0];</span>
        }
<span class="fc" id="L177">        return Object.class;</span>
    }

    /**
     * Returns the component type of the given type if it is an array, {@code null} if it is not.
     *
     * @param type the given type
     * @return the component type of the given type if it is an array, {@code null} if it is not
     */
    public static @Nullable Type getComponentType(@Nonnull Type type) {
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (isClass(type)) {</span>
<span class="fc" id="L188">            return ((Class&lt;?&gt;) type).getComponentType();</span>
        }
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (isGenericArray(type)) {</span>
<span class="fc" id="L191">            return ((GenericArrayType) type).getGenericComponentType();</span>
        }
<span class="fc" id="L193">        return null;</span>
    }

    /**
     * Returns the runtime class of the given type, may be {@code null} if fails. This method supports {@link Class},
     * {@link ParameterizedType}, {@link GenericArrayType} and {@link TypeVariable}.
     *
     * @param type the given type
     * @return the runtime class of the given type, may be {@code null} if fails
     */
    public static @Nullable Class&lt;?&gt; toRuntimeClass(@Nonnull Type type) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (isClass(type)) {</span>
<span class="fc" id="L205">            return (Class&lt;?&gt;) type;</span>
        }
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (isParameterized(type)) {</span>
<span class="fc" id="L208">            ParameterizedType parameterizedType = (ParameterizedType) type;</span>
<span class="fc" id="L209">            Type rawType = parameterizedType.getRawType();</span>
<span class="fc" id="L210">            return toRuntimeClass(rawType);</span>
        }
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (isGenericArray(type)) {</span>
<span class="fc" id="L213">            GenericArrayType arrayType = (GenericArrayType) type;</span>
<span class="fc" id="L214">            Type componentType = arrayType.getGenericComponentType();</span>
<span class="fc" id="L215">            @Nullable Class&lt;?&gt; componentClass = toRuntimeClass(componentType);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">            if (componentClass == null) {</span>
<span class="fc" id="L217">                return null;</span>
            }
<span class="fc" id="L219">            return ClassKit.arrayClass(componentClass);</span>
        }
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (isTypeVariable(type)) {</span>
<span class="fc" id="L222">            return toRuntimeClass(getFirstBound((TypeVariable&lt;?&gt;) type));</span>
        }
<span class="fc" id="L224">        return null;</span>
    }

    /**
     * Returns whether a type can be assigned by another type. This method is {@link Type} version of
     * {@link Class#isAssignableFrom(Class)}, supporting {@link Class}, {@link ParameterizedType}, {@link WildcardType},
     * {@link TypeVariable} and {@link GenericArrayType}.
     *
     * @param assigned the type to be assigned
     * @param assignee the assignee type
     * @return whether a type can be assigned by another type
     */
    public static boolean isAssignable(@Nonnull Type assigned, @Nonnull Type assignee) {
<span class="fc" id="L237">        return AssignBack.isAssignable(assigned, assignee);</span>
    }

    /**
     * Resolves and returns the actual type arguments of the given type, based on the type parameters of the specified
     * base type, in order of those type parameters.
     * &lt;p&gt;
     * For example, here is a base type: {@code interface Base&lt;A, B, C&gt;}, and a subtype to be resolved:
     * {@code class Sub implements Base&lt;String, Integer, Long&gt;}. The result of the
     * {@code resolveActualTypeArguments(subtype, base)} will be the list of:
     * {@code [String.class, Integer.class, Long.class]}.
     * &lt;p&gt;
     * The given type to be resolved must be a {@link Class}, {@link ParameterizedType} or array. If it is a
     * {@link Class}, it must be a sub or same type of the base type; if it is a {@link ParameterizedType}, its raw type
     * must be a sub or same type of the base type; if it is an array, the base type must also be an array, and this
     * method calls itself with their component types.
     * &lt;p&gt;
     * Note this method does not guarantee that all type parameters can be resolved, and unresolved type parameters will
     * be directly returned to the list at the corresponding index.
     *
     * @param type     the given type to be resolved
     * @param baseType the specified base type
     * @return the actual type arguments of the given type, based on the type parameters of the specified base type, in
     * order of those type parameters
     * @throws ReflectionException if the given type cannot be resolved
     */
    public static @Nonnull List&lt;@Nonnull Type&gt; resolveActualTypeArguments(
        @Nonnull Type type, @Nonnull Class&lt;?&gt; baseType
    ) throws ReflectionException {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (baseType.isArray()) {</span>
<span class="fc" id="L267">            Type componentType = TypeKit.getComponentType(type);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            if (componentType == null) {</span>
<span class="fc" id="L269">                throw new ReflectionException(&quot;Unsupported resolving between &quot; + type + &quot; and &quot; + baseType);</span>
            }
<span class="fc" id="L271">            return resolveActualTypeArguments(componentType, baseType.getComponentType());</span>
        }
<span class="fc" id="L273">        @Nullable Class&lt;?&gt; cls = TypeKit.toRuntimeClass(type);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (cls == null) {</span>
<span class="fc" id="L275">            throw new ReflectionException(&quot;Unsupported type: &quot; + type + &quot;.&quot;);</span>
        }
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (!baseType.isAssignableFrom(cls)) {</span>
<span class="fc" id="L278">            throw new ReflectionException(&quot;Unsupported resolving between &quot; + type + &quot; and &quot; + baseType);</span>
        }
        // Resolves:
<span class="fc" id="L281">        TypeVariable&lt;?&gt;[] typeParameters = baseType.getTypeParameters();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (ArrayKit.isEmpty(typeParameters)) {</span>
<span class="fc" id="L283">            return Collections.emptyList();</span>
        }
<span class="fc" id="L285">        Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeArguments = typeParametersMapping(type);</span>
<span class="fc" id="L286">        Set&lt;Type&gt; stack = new HashSet&lt;&gt;();</span>
<span class="fc" id="L287">        return Fs.stream(typeParameters)</span>
<span class="fc" id="L288">            .map(typeVariable -&gt; {</span>
<span class="fc" id="L289">                Type actualType = MapKit.resolveChain(typeArguments, typeVariable, stack);</span>
<span class="fc" id="L290">                stack.clear();</span>
<span class="fc" id="L291">                return Fs.nonnull(actualType, typeVariable);</span>
            })
<span class="fc" id="L293">            .collect(Collectors.toList());</span>
    }

    /**
     * Returns a map contains the mapping of type parameters for the given type, the key is type parameter, and the
     * value is the actual type argument or inherited type parameter. For example, these types:
     * &lt;pre&gt;{@code
     *     class X extends Y&lt;Integer, Long&gt;
     *     class Y&lt;K, V&gt; implements Z&lt;Float, Double, V&gt;
     *     interface Z&lt;T, U, R&gt;
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * The result of {@code resolveTypeParameterMapping(X.class)} will be:
     * &lt;pre&gt;{@code
     *     T -&gt; Float
     *     U -&gt; Double
     *     R -&gt; V
     *     K -&gt; Integer
     *     V -&gt; Long
     * }&lt;/pre&gt;
     *
     * @param type the given type
     * @return a map contains the mapping of type parameters for the given type
     */
    public static @Nonnull Map&lt;@Nonnull TypeVariable&lt;?&gt;, @Nullable Type&gt; typeParametersMapping(
        @Nonnull Type type
    ) {
<span class="fc" id="L320">        Map&lt;TypeVariable&lt;?&gt;, Type&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L321">        typeParametersMapping(type, result);</span>
<span class="fc" id="L322">        return result;</span>
    }

    private static void typeParametersMapping(
        @Nonnull Type type,
        @Nonnull @OutParam Map&lt;@Nonnull TypeVariable&lt;?&gt;, @Nullable Type&gt; mapping
    ) {
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (TypeKit.isClass(type)) {</span>
<span class="fc" id="L330">            Class&lt;?&gt; cur = (Class&lt;?&gt;) type;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            while (cur != null) {</span>
<span class="fc" id="L332">                @Nullable Type superclass = cur.getGenericSuperclass();</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                if (superclass != null) {</span>
<span class="fc" id="L334">                    mapTypeVariables(superclass, mapping);</span>
                }
<span class="fc" id="L336">                Type[] interfaces = cur.getGenericInterfaces();</span>
<span class="fc" id="L337">                mapTypeVariables(interfaces, mapping);</span>
<span class="fc" id="L338">                cur = cur.getSuperclass();</span>
<span class="fc" id="L339">            }</span>
        }
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (TypeKit.isParameterized(type)) {</span>
<span class="fc" id="L342">            mapTypeVariables(type, mapping);</span>
<span class="fc" id="L343">            typeParametersMapping(((ParameterizedType) type).getRawType(), mapping);</span>
        }
<span class="fc" id="L345">    }</span>

    private static void mapTypeVariables(
        @Nonnull Type @Nonnull [] interfaces,
        @Nonnull @OutParam Map&lt;@Nonnull TypeVariable&lt;?&gt;, @Nullable Type&gt; mapping
    ) {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (ArrayKit.isEmpty(interfaces)) {</span>
<span class="fc" id="L352">            return;</span>
        }
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (Type anInterface : interfaces) {</span>
<span class="fc" id="L355">            mapTypeVariables(anInterface, mapping);</span>
            // never null
<span class="fc" id="L357">            Class&lt;?&gt; rawClass = TypeKit.getRawClass(anInterface);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">            if (rawClass == null) {</span>
                // unreachable
<span class="fc" id="L360">                continue;</span>
            }
<span class="fc" id="L362">            mapTypeVariables(rawClass.getGenericInterfaces(), mapping);</span>
        }
<span class="fc" id="L364">    }</span>

    private static void mapTypeVariables(
        @Nonnull Type type,
        @Nonnull @OutParam Map&lt;@Nonnull TypeVariable&lt;?&gt;, @Nullable Type&gt; mapping
    ) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (!TypeKit.isParameterized(type)) {</span>
<span class="fc" id="L371">            return;</span>
        }
<span class="fc" id="L373">        ParameterizedType parameterizedType = (ParameterizedType) type;</span>
<span class="fc" id="L374">        Type[] typeArguments = parameterizedType.getActualTypeArguments();</span>
        // never null
<span class="fc" id="L376">        Class&lt;?&gt; rawClass = TypeKit.getRawClass(parameterizedType);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (rawClass == null) {</span>
            // unreachable
<span class="fc" id="L379">            return;</span>
        }
<span class="fc" id="L381">        TypeVariable&lt;?&gt;[] typeParameters = rawClass.getTypeParameters();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        for (int i = 0; i &lt; typeParameters.length; i++) {</span>
<span class="fc" id="L383">            TypeVariable&lt;?&gt; typeParameter = typeParameters[i];</span>
<span class="fc" id="L384">            Type typeArgument = typeArguments[i];</span>
<span class="fc" id="L385">            mapping.put(typeParameter, typeArgument);</span>
        }
<span class="fc" id="L387">    }</span>

    /**
     * Resolves the given type and replaces the resolved {@link Class} types, which equal to the specified matching
     * type, with the specified replacement. Returns the fully replaced type (or the original type itself if no
     * replacement were made).
     * &lt;p&gt;
     * For example, for a type: {@code Map&lt;String, Integer&gt;}, the result of
     * {@code replaceType(type, Integer.class, Long.class)} is: {@code Map&lt;String, Long&gt;}. Note the given type itself
     * can also be replaced.
     * &lt;p&gt;
     * This method supports resolving {@link Class}, {@link ParameterizedType}, {@link WildcardType} and
     * {@link GenericArrayType}.
     *
     * @param type        the given type to be resolved
     * @param matching    the specified matching type
     * @param replacement the specified replacement
     * @return the type after the replacing
     * @throws ReflectionException if an error occurs during the replacing
     */
    public static @Nonnull Type replaceType(
        @Nonnull Type type,
        @Nonnull Class&lt;?&gt; matching,
        @Nonnull Type replacement
    ) throws ReflectionException {
<span class="fc bfc" id="L412" title="All 2 branches covered.">        return replaceType(type, t -&gt; Objects.equals(t, matching) ? replacement : t);</span>
    }

    /**
     * Resolves the given type, passes resolved {@link Class} types to the given mapper, and replaces them with the
     * mapper's results which are not equal to the original passed {@link Class} types (via
     * {@link Objects#equals(Object, Object)}). Returns the fully replaced type (or the original type itself if no
     * replacement were made).
     * &lt;p&gt;
     * For example, for a type: {@code Map&lt;String, Integer&gt;}, the result of
     * {@code replaceType(type, t -&gt; Objects.equals(t, Integer.class) ? Long.class : t)} is: {@code Map&lt;String, Long&gt;}.
     * Note the given type itself can also be replaced if it is a {@link Class} and the mapper's result is not equals to
     * it.
     * &lt;p&gt;
     * This method supports resolving {@link Class}, {@link ParameterizedType}, {@link WildcardType} and
     * {@link GenericArrayType}.
     *
     * @param type   the given type to be resolved
     * @param mapper the given mapper
     * @return the type after the replacing
     * @throws ReflectionException if an error occurs during the replacing
     */
    public static @Nonnull Type replaceType(
        @Nonnull Type type,
        @Nonnull Function&lt;? super @Nonnull Class&lt;?&gt;, ? extends @Nonnull Type&gt; mapper
    ) throws ReflectionException {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (TypeKit.isClass(type)) {</span>
<span class="fc" id="L439">            Type newType = mapper.apply((Class&lt;?&gt;) type);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (!Objects.equals(type, newType)) {</span>
<span class="fc" id="L441">                return newType;</span>
            }
        }
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (TypeKit.isParameterized(type)) {</span>
<span class="fc" id="L445">            return replaceType((ParameterizedType) type, mapper);</span>
        }
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (TypeKit.isWildcard(type)) {</span>
<span class="fc" id="L448">            return replaceType((WildcardType) type, mapper);</span>
        }
<span class="fc bfc" id="L450" title="All 2 branches covered.">        if (TypeKit.isGenericArray(type)) {</span>
<span class="fc" id="L451">            return replaceType((GenericArrayType) type, mapper);</span>
        }
<span class="fc" id="L453">        return type;</span>
    }

    private static @Nonnull Type replaceType(
        @Nonnull ParameterizedType type,
        @Nonnull Function&lt;? super @Nonnull Class&lt;?&gt;, ? extends @Nonnull Type&gt; mapper
    ) throws ReflectionException {
<span class="fc" id="L460">        boolean matched = false;</span>
<span class="fc" id="L461">        Type rawType = type.getRawType();</span>
<span class="fc" id="L462">        Type newRawType = replaceType(rawType, mapper);</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (!TypeKit.isClass(newRawType)) {</span>
<span class="fc" id="L464">            throw new ReflectionException(&quot;Unsupported raw type: &quot; + newRawType + &quot;.&quot;);</span>
        }
<span class="fc bfc" id="L466" title="All 2 branches covered.">        if (!Objects.equals(rawType, newRawType)) {</span>
<span class="fc" id="L467">            matched = true;</span>
        }
<span class="fc" id="L469">        @Nullable Type ownerType = type.getOwnerType();</span>
<span class="fc" id="L470">        Type newOwnerType = null;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        if (ownerType != null) {</span>
<span class="fc" id="L472">            newOwnerType = replaceType(ownerType, mapper);</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (!Objects.equals(ownerType, newOwnerType)) {</span>
<span class="fc" id="L474">                matched = true;</span>
            }
        }
<span class="fc" id="L477">        Type[] actualTypeArguments = type.getActualTypeArguments();</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">        for (int i = 0; i &lt; actualTypeArguments.length; i++) {</span>
<span class="fc" id="L479">            Type actualTypeArgument = actualTypeArguments[i];</span>
<span class="fc" id="L480">            Type newActualTypeArgument = replaceType(actualTypeArgument, mapper);</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">            if (!Objects.equals(actualTypeArgument, newActualTypeArgument)) {</span>
<span class="fc" id="L482">                matched = true;</span>
<span class="fc" id="L483">                actualTypeArguments[i] = newActualTypeArgument;</span>
            }
        }
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (matched) {</span>
<span class="fc" id="L487">            return TypeKit.parameterizedType((Class&lt;?&gt;) newRawType, actualTypeArguments, newOwnerType);</span>
        } else {
<span class="fc" id="L489">            return type;</span>
        }
    }

    private static @Nonnull Type replaceType(
        @Nonnull WildcardType type,
        @Nonnull Function&lt;? super @Nonnull Class&lt;?&gt;, ? extends @Nonnull Type&gt; mapper
    ) throws ReflectionException {
<span class="fc" id="L497">        boolean matched = false;</span>
<span class="fc" id="L498">        Type[] upperBounds = type.getUpperBounds();</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">        for (int i = 0; i &lt; upperBounds.length; i++) {</span>
<span class="fc" id="L500">            Type upperBound = upperBounds[i];</span>
<span class="fc" id="L501">            Type newUpperBound = replaceType(upperBound, mapper);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            if (!Objects.equals(upperBound, newUpperBound)) {</span>
<span class="fc" id="L503">                matched = true;</span>
<span class="fc" id="L504">                upperBounds[i] = newUpperBound;</span>
            }
        }
<span class="fc" id="L507">        Type[] lowerBounds = type.getLowerBounds();</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        for (int i = 0; i &lt; lowerBounds.length; i++) {</span>
<span class="fc" id="L509">            Type lowerBound = lowerBounds[i];</span>
<span class="fc" id="L510">            Type newLowerBound = replaceType(lowerBound, mapper);</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">            if (!Objects.equals(lowerBound, newLowerBound)) {</span>
<span class="fc" id="L512">                matched = true;</span>
<span class="fc" id="L513">                lowerBounds[i] = newLowerBound;</span>
            }
        }
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (matched) {</span>
<span class="fc" id="L517">            return TypeKit.wildcardType(upperBounds, lowerBounds);</span>
        } else {
<span class="fc" id="L519">            return type;</span>
        }
    }

    private static @Nonnull Type replaceType(
        @Nonnull GenericArrayType type,
        @Nonnull Function&lt;? super @Nonnull Class&lt;?&gt;, ? extends @Nonnull Type&gt; mapper
    ) throws ReflectionException {
<span class="fc" id="L527">        boolean matched = false;</span>
<span class="fc" id="L528">        Type componentType = type.getGenericComponentType();</span>
<span class="fc" id="L529">        Type newComponentType = replaceType(componentType, mapper);</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">        if (!Objects.equals(componentType, newComponentType)) {</span>
<span class="fc" id="L531">            matched = true;</span>
        }
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if (matched) {</span>
<span class="fc" id="L534">            return TypeKit.arrayType(newComponentType);</span>
        } else {
<span class="fc" id="L536">            return type;</span>
        }
    }

    /**
     * Returns a new {@link ParameterizedType} with the specified raw type and actual type arguments.
     *
     * @param rawType             the raw type
     * @param actualTypeArguments the actual type arguments
     * @return a new {@link ParameterizedType} with the specified raw type and actual type arguments
     */
    public static @Nonnull ParameterizedType parameterizedType(
        @Nonnull Class&lt;?&gt; rawType,
        @Nonnull Type @Nonnull @RetainedParam [] actualTypeArguments
    ) {
<span class="fc" id="L551">        return parameterizedType(rawType, actualTypeArguments, null);</span>
    }

    /**
     * Returns a new {@link ParameterizedType} with the specified raw type, actual type arguments and owner type. The
     * owner type may be {@code null}, and if it is {@code null}, the owner type will be the result of
     * {@link Class#getDeclaringClass()}.
     *
     * @param rawType             the raw type
     * @param actualTypeArguments the actual type arguments
     * @param ownerType           the owner type
     * @return a new {@link ParameterizedType} with the specified raw type, actual type arguments and owner type
     */
    public static @Nonnull ParameterizedType parameterizedType(
        @Nonnull Class&lt;?&gt; rawType,
        @Nonnull Type @Nonnull @RetainedParam [] actualTypeArguments,
        @Nullable Type ownerType
    ) {
<span class="fc" id="L569">        return new ParameterizedTypeImpl(rawType, actualTypeArguments, ownerType);</span>
    }

    /**
     * Returns a new {@link WildcardType} with the specified upper bound ({@code ? extends}).
     *
     * @param upperBound the upper bound
     * @return a new {@link WildcardType} with the specified upper bound ({@code ? extends})
     */
    public static @Nonnull WildcardType upperWildcard(@Nonnull Type upperBound) {
<span class="fc" id="L579">        return new WildcardTypeImpl(Fs.array(upperBound), WildcardTypeImpl.EMPTY_BOUNDS);</span>
    }

    /**
     * Returns a new {@link WildcardType} with the specified lower bound ({@code ? super}).
     *
     * @param lowerBounds the lower bound
     * @return a new {@link WildcardType} with the specified lower bound ({@code ? super})
     */
    public static @Nonnull WildcardType lowerWildcard(@Nonnull Type lowerBounds) {
<span class="fc" id="L589">        return new WildcardTypeImpl(WildcardTypeImpl.OBJECT_BOUND, Fs.array(lowerBounds));</span>
    }

    /**
     * Returns a singleton {@link WildcardType} represents {@code ?}.
     *
     * @return a singleton {@link WildcardType} represents {@code ?}
     */
    public static @Nonnull WildcardType wildcardChar() {
<span class="fc" id="L598">        return WildcardTypeImpl.QUESTION_MARK;</span>
    }

    /**
     * Returns a new {@link WildcardType} with the specified upper bounds and lower bounds.
     *
     * @param upperBounds the upper bounds
     * @param lowerBounds the lower bounds
     * @return a new {@link WildcardType} with the specified upper bounds and lower bounds
     */
    public static @Nonnull WildcardType wildcardType(
        @Nonnull Type @Nonnull @RetainedParam [] upperBounds,
        @Nonnull Type @Nonnull @RetainedParam [] lowerBounds
    ) {
<span class="fc" id="L612">        return new WildcardTypeImpl(upperBounds, lowerBounds);</span>
    }

    /**
     * Returns a new {@link GenericArrayType} with the specified component type.
     *
     * @param componentType the component type
     * @return a new {@link GenericArrayType} with the specified component type
     */
    public static @Nonnull GenericArrayType arrayType(@Nonnull Type componentType) {
<span class="fc" id="L622">        return new GenericArrayTypeImpl(componentType);</span>
    }

    /**
     * Returns a new instance of {@link Type}. Note the type of the instance is &lt;b&gt;NOT&lt;/b&gt; the {@link Class},
     * {@link ParameterizedType}, {@link WildcardType}, {@link TypeVariable} or {@link GenericArrayType}.
     *
     * @return a new instance of {@link Type}
     */
    public static @Nonnull Type otherType() {
<span class="fc" id="L632">        return new OtherType();</span>
    }

    private static final class ParameterizedTypeImpl implements ParameterizedType {

        private final @Nonnull Class&lt;?&gt; rawType;
        private final @Nonnull Type @Nonnull [] actualTypeArguments;
        private final @Nullable Type ownerType;

        private ParameterizedTypeImpl(
            @Nonnull Class&lt;?&gt; rawType,
            @Nonnull Type @Nonnull @RetainedParam [] actualTypeArguments,
            @Nullable Type ownerType
<span class="fc" id="L645">        ) {</span>
<span class="fc" id="L646">            this.rawType = rawType;</span>
<span class="fc" id="L647">            this.actualTypeArguments = actualTypeArguments;</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">            this.ownerType = ownerType != null ? ownerType : rawType.getDeclaringClass();</span>
<span class="fc" id="L649">        }</span>

        @Override
        public @Nonnull Type @Nonnull [] getActualTypeArguments() {
<span class="fc" id="L653">            return actualTypeArguments.clone();</span>
        }

        @Override
        public @Nonnull Type getRawType() {
<span class="fc" id="L658">            return rawType;</span>
        }

        @Override
        public @Nullable Type getOwnerType() {
<span class="fc" id="L663">            return ownerType;</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="fc bfc" id="L668" title="All 2 branches covered.">            if (this == o) {</span>
<span class="fc" id="L669">                return true;</span>
            }
<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (o == null) {</span>
<span class="fc" id="L672">                return false;</span>
            }
<span class="fc bfc" id="L674" title="All 2 branches covered.">            if (o instanceof ParameterizedTypeImpl) {</span>
<span class="fc" id="L675">                ParameterizedTypeImpl that = (ParameterizedTypeImpl) o;</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">                return Objects.equals(ownerType, that.ownerType) &amp;&amp;</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">                    Objects.equals(rawType, that.rawType) &amp;&amp;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">                    Arrays.equals(actualTypeArguments, that.actualTypeArguments);</span>
            }
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (o instanceof ParameterizedType) {</span>
<span class="fc" id="L681">                ParameterizedType that = (ParameterizedType) o;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                return Objects.equals(ownerType, that.getOwnerType()) &amp;&amp;</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">                    Objects.equals(rawType, that.getRawType()) &amp;&amp;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">                    Arrays.equals(actualTypeArguments, that.getActualTypeArguments());</span>
            }
<span class="fc" id="L686">            return false;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L691">            return Arrays.hashCode(actualTypeArguments) ^</span>
<span class="fc" id="L692">                Objects.hashCode(ownerType) ^</span>
<span class="fc" id="L693">                Objects.hashCode(rawType);</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L698">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">            if (ownerType != null) {</span>
                // test.A&lt;T&gt;
<span class="fc" id="L701">                sb.append(ownerType.getTypeName());</span>
                // test.A&lt;T&gt;$
<span class="fc" id="L703">                sb.append(&quot;$&quot;);</span>
                // test.A&lt;T&gt;$B
<span class="fc" id="L705">                sb.append(rawType.getSimpleName());</span>
            } else {
                // test.B
<span class="fc" id="L708">                sb.append(rawType.getTypeName());</span>
            }
            // &lt;...&gt;
<span class="fc" id="L711">            sb.append(&quot;&lt;&quot;);</span>
<span class="fc" id="L712">            sb.append(Fs.stream(actualTypeArguments)</span>
<span class="fc" id="L713">                .map(Type::getTypeName)</span>
<span class="fc" id="L714">                .collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="fc" id="L715">            sb.append(&quot;&gt;&quot;);</span>
<span class="fc" id="L716">            return sb.toString();</span>
        }
    }

    private static class WildcardTypeImpl implements WildcardType {

<span class="fc" id="L722">        private static final @Nonnull Type @Nonnull [] EMPTY_BOUNDS = {};</span>
<span class="fc" id="L723">        private static final @Nonnull Type @Nonnull [] OBJECT_BOUND = {Object.class};</span>
<span class="fc" id="L724">        private static final WildcardType QUESTION_MARK = new WildcardTypeImpl(</span>
<span class="fc" id="L725">            Fs.array(Object.class), EMPTY_BOUNDS</span>
        );

        private final @Nonnull Type @Nonnull [] upperBounds;
        private final @Nonnull Type @Nonnull [] lowerBounds;

        private WildcardTypeImpl(
            @Nonnull Type @Nonnull @RetainedParam [] upperBounds,
            @Nonnull Type @Nonnull @RetainedParam [] lowerBounds
<span class="fc" id="L734">        ) {</span>
<span class="fc" id="L735">            this.upperBounds = upperBounds;</span>
<span class="fc" id="L736">            this.lowerBounds = lowerBounds;</span>
<span class="fc" id="L737">        }</span>

        @Override
        public @Nonnull Type @Nonnull [] getUpperBounds() {
<span class="fc" id="L741">            return upperBounds.clone();</span>
        }

        @Override
        public @Nonnull Type @Nonnull [] getLowerBounds() {
<span class="fc bfc" id="L746" title="All 2 branches covered.">            return lowerBounds.length == 0 ? lowerBounds : lowerBounds.clone();</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="fc bfc" id="L751" title="All 2 branches covered.">            if (this == o) {</span>
<span class="fc" id="L752">                return true;</span>
            }
<span class="fc bfc" id="L754" title="All 2 branches covered.">            if (o == null) {</span>
<span class="fc" id="L755">                return false;</span>
            }
<span class="fc bfc" id="L757" title="All 2 branches covered.">            if (o instanceof WildcardTypeImpl) {</span>
<span class="fc" id="L758">                WildcardTypeImpl that = (WildcardTypeImpl) o;</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">                return Arrays.equals(lowerBounds, that.lowerBounds) &amp;&amp;</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">                    Arrays.equals(upperBounds, that.upperBounds);</span>
            }
<span class="fc bfc" id="L762" title="All 2 branches covered.">            if (o instanceof WildcardType) {</span>
<span class="fc" id="L763">                WildcardType that = (WildcardType) o;</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">                return Arrays.equals(lowerBounds, that.getLowerBounds()) &amp;&amp;</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">                    Arrays.equals(upperBounds, that.getUpperBounds());</span>
            }
<span class="fc" id="L767">            return false;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L772">            return Arrays.hashCode(lowerBounds) ^ Arrays.hashCode(upperBounds);</span>
        }

        @Override
        public String toString() {
<span class="fc bfc" id="L777" title="All 2 branches covered.">            if (lowerBounds.length &gt; 0) {</span>
                // ? super
<span class="fc" id="L779">                return &quot;? super &quot; + lowerBounds[0].getTypeName();</span>
            }
<span class="fc bfc" id="L781" title="All 2 branches covered.">            if (upperBounds.length &gt; 0) {</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">                if (Objects.equals(upperBounds[0], Object.class)) {</span>
<span class="fc" id="L783">                    return &quot;?&quot;;</span>
                }
                // ? extends
<span class="fc" id="L786">                return &quot;? extends &quot; + upperBounds[0].getTypeName();</span>
            }
            // unknown
<span class="fc" id="L789">            return &quot;??&quot;;</span>
        }
    }

    private static final class GenericArrayTypeImpl implements GenericArrayType {

        private final @Nonnull Type componentType;

<span class="fc" id="L797">        private GenericArrayTypeImpl(@Nonnull Type componentType) {</span>
<span class="fc" id="L798">            this.componentType = componentType;</span>
<span class="fc" id="L799">        }</span>

        @Override
        public @Nonnull Type getGenericComponentType() {
<span class="fc" id="L803">            return componentType;</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="fc bfc" id="L808" title="All 2 branches covered.">            if (this == o) {</span>
<span class="fc" id="L809">                return true;</span>
            }
<span class="fc bfc" id="L811" title="All 2 branches covered.">            if (o == null) {</span>
<span class="fc" id="L812">                return false;</span>
            }
<span class="fc bfc" id="L814" title="All 2 branches covered.">            if (o instanceof GenericArrayType) {</span>
<span class="fc" id="L815">                GenericArrayType other = (GenericArrayType) o;</span>
<span class="fc" id="L816">                return Objects.equals(componentType, other.getGenericComponentType());</span>
            }
<span class="fc" id="L818">            return false;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L823">            return Objects.hashCode(componentType);</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L828">            return componentType.getTypeName() + &quot;[]&quot;;</span>
        }
    }

    private static final class OtherType implements Type {

        @Override
        public @Nonnull String getTypeName() {
<span class="fc" id="L836">            return getClass().getName();</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="fc" id="L841">            return super.equals(o);</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L846">            return toString().hashCode();</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L851">            return getTypeName();</span>
        }
    }

    private TypeKit() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>