<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassKit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.reflect</a> &gt; <span class="el_source">ClassKit.java</span></div><h1>ClassKit.java</h1><pre class="source lang-java linenums">package space.sunqian.common.reflect;

import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.annotations.RetainedParam;
import space.sunqian.common.Fs;
import space.sunqian.common.base.exception.UnknownPrimitiveTypeException;
import space.sunqian.common.base.system.JvmKit;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Iterator;
import java.util.Objects;

/**
 * Utilities for {@link Class}.
 *
 * @author sunqian
 */
public class ClassKit {

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found. This method first
     * uses {@link Class#getField(String)}. If not found, it will use {@link Class#getDeclaredField(String)} to try
     * again.
     *
     * @param cls  the given class
     * @param name the specified field name
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field getField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name) {
<span class="fc" id="L38">        return getField(cls, name, true);</span>
    }

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found. This method first
     * uses {@link Class#getField(String)}. If not found and the {@code searchDeclared} is {@code true}, it will use
     * {@link Class#getDeclaredField(String)} to try again.
     *
     * @param cls            the given class
     * @param name           the specified field name
     * @param searchDeclared specifies whether searches declared fields
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field getField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name, boolean searchDeclared) {
        try {
<span class="fc" id="L53">            return cls.getField(name);</span>
<span class="fc" id="L54">        } catch (NoSuchFieldException e) {</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L57">                    return cls.getDeclaredField(name);</span>
<span class="fc" id="L58">                } catch (NoSuchFieldException ex) {</span>
<span class="fc" id="L59">                    return null;</span>
                }
            }
        }
<span class="fc" id="L63">        return null;</span>
    }

    /**
     * Returns the field of the specified name from the given class, or {@code null} if not found.
     * &lt;p&gt;
     * This method searches via {@link Class#getField(String)}. If the field is not found, then this method will use
     * {@link Class#getDeclaredField(String)} to search again. If the field is still not found, then this method will
     * traverse the hierarchy of superclasses and interfaces of the given class to search via
     * {@link Class#getDeclaredField(String)}.
     *
     * @param cls  the given class
     * @param name the specified field name
     * @return the field of the specified name from the given class, or {@code null} if not found
     */
    public static @Nullable Field searchField(@Nonnull Class&lt;?&gt; cls, @Nonnull String name) {
<span class="fc" id="L79">        Field field = getField(cls, name);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (field != null) {</span>
<span class="fc" id="L81">            return field;</span>
        }
<span class="fc" id="L83">        Iterator&lt;Class&lt;?&gt;&gt; supertypesAndInterfaces = toSupertypesAndInterfaces(cls);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        while (supertypesAndInterfaces.hasNext()) {</span>
<span class="fc" id="L85">            Class&lt;?&gt; next = supertypesAndInterfaces.next();</span>
<span class="fc" id="L86">            @Nullable Field nextField = searchField(next, name);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if (nextField != null) {</span>
<span class="fc" id="L88">                return nextField;</span>
            }
<span class="fc" id="L90">        }</span>
<span class="fc" id="L91">        return null;</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * This method first uses {@link Class#getMethod(String, Class[])}. If not found, it will use
     * {@link Class#getDeclaredMethod(String, Class[])} to try again.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method getMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L109">        return getMethod(cls, name, parameterTypes, true);</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * This method first uses {@link Class#getMethod(String, Class[])}. If not found and the {@code searchDeclared} is
     * {@code true}, it will use {@link Class#getDeclaredMethod(String, Class[])} to try again.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @param searchDeclared specifies whether searches declared methods
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method getMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes,
        boolean searchDeclared
    ) {
        try {
<span class="fc" id="L130">            return cls.getMethod(name, parameterTypes);</span>
<span class="fc" id="L131">        } catch (NoSuchMethodException e) {</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L134">                    return cls.getDeclaredMethod(name, parameterTypes);</span>
<span class="fc" id="L135">                } catch (NoSuchMethodException ex) {</span>
<span class="fc" id="L136">                    return null;</span>
                }
            }
        }
<span class="fc" id="L140">        return null;</span>
    }

    /**
     * Returns the method of the specified name and parameter types from the given class, or {@code null} if not found.
     * &lt;p&gt;
     * This method searches via {@link Class#getMethod(String, Class[])}. If the method is not found, then this method
     * will use {@link Class#getDeclaredMethod(String, Class[])} to search again. If the method is still not found, then
     * this method will traverse the hierarchy of superclasses and interfaces of the given class to search via
     * {@link Class#getDeclaredMethod(String, Class[])}.
     *
     * @param cls            the given class
     * @param name           the specified method name
     * @param parameterTypes the specified parameter types
     * @return the method of the specified name and parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Method searchMethod(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull String name,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L161">        Method method = getMethod(cls, name, parameterTypes);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (method != null) {</span>
<span class="fc" id="L163">            return method;</span>
        }
<span class="fc" id="L165">        Iterator&lt;Class&lt;?&gt;&gt; supertypesAndInterfaces = toSupertypesAndInterfaces(cls);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        while (supertypesAndInterfaces.hasNext()) {</span>
<span class="fc" id="L167">            Class&lt;?&gt; next = supertypesAndInterfaces.next();</span>
<span class="fc" id="L168">            @Nullable Method nextMethod = searchMethod(next, name, parameterTypes);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (nextMethod != null) {</span>
<span class="fc" id="L170">                return nextMethod;</span>
            }
<span class="fc" id="L172">        }</span>
<span class="fc" id="L173">        return null;</span>
    }

    private static @Nonnull Iterator&lt;Class&lt;?&gt;&gt; toSupertypesAndInterfaces(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L177">        return new Iterator&lt;Class&lt;?&gt;&gt;() {</span>

<span class="fc" id="L179">            private int index = -1;</span>
            private Class&lt;?&gt; @Nullable [] interfaces;
<span class="fc" id="L181">            private @Nullable Class&lt;?&gt; next = getNext();</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L185" title="All 2 branches covered.">                return next != null;</span>
            }

            @Override
            public Class&lt;?&gt; next() {
<span class="fc" id="L190">                Class&lt;?&gt; result = next;</span>
<span class="fc" id="L191">                next = getNext();</span>
<span class="fc" id="L192">                return result;</span>
            }

            private @Nullable Class&lt;?&gt; getNext() {
<span class="fc bfc" id="L196" title="All 2 branches covered.">                if (index == -1) {</span>
<span class="fc" id="L197">                    index++;</span>
<span class="fc" id="L198">                    Class&lt;?&gt; superclass = cls.getSuperclass();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">                    if (superclass != null) {</span>
<span class="fc" id="L200">                        return superclass;</span>
                    }
                }
<span class="fc bfc" id="L203" title="All 2 branches covered.">                if (interfaces == null) {</span>
<span class="fc" id="L204">                    interfaces = cls.getInterfaces();</span>
                }
<span class="fc bfc" id="L206" title="All 2 branches covered.">                if (index &lt; interfaces.length) {</span>
<span class="fc" id="L207">                    return interfaces[index++];</span>
                }
<span class="fc" id="L209">                return null;</span>
            }
        };
    }

    /**
     * Returns the constructor of the specified parameter types from the given class, or {@code null} if not found. This
     * method first uses {@link Class#getConstructor(Class[])}. If not found, it will use
     * {@link Class#getDeclaredConstructor(Class[])} to try again.
     *
     * @param cls            the given class
     * @param parameterTypes the specified parameter types
     * @return the constructor of the specified parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Constructor&lt;?&gt; getConstructor(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes
    ) {
<span class="fc" id="L227">        return getConstructor(cls, parameterTypes, true);</span>
    }

    /**
     * Returns the constructor of the specified parameter types from the given class, or {@code null} if not found. This
     * method first uses {@link Class#getConstructor(Class[])}. If not found and the {@code searchDeclared} is
     * {@code true}, it will use {@link Class#getDeclaredConstructor(Class[])} to try again.
     *
     * @param cls            the given class
     * @param parameterTypes the specified parameter types
     * @param searchDeclared specifies whether searches declared constructors
     * @return the constructor of the specified parameter types from the given class, or {@code null} if not found
     */
    public static @Nullable Constructor&lt;?&gt; getConstructor(
        @Nonnull Class&lt;?&gt; cls,
        @Nonnull Class&lt;?&gt; @Nonnull @RetainedParam [] parameterTypes,
        boolean searchDeclared
    ) {
        try {
<span class="fc" id="L246">            return cls.getConstructor(parameterTypes);</span>
<span class="fc" id="L247">        } catch (NoSuchMethodException e) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (searchDeclared) {</span>
                try {
<span class="fc" id="L250">                    return cls.getDeclaredConstructor(parameterTypes);</span>
<span class="fc" id="L251">                } catch (NoSuchMethodException ex) {</span>
<span class="fc" id="L252">                    return null;</span>
                }
            }
        }
<span class="fc" id="L256">        return null;</span>
    }

    /**
     * Returns a new instance for the given class name with the empty constructor, may be {@code null} if fails.
     * &lt;p&gt;
     * This method first uses {@link #classForName(String, ClassLoader)} to get the class of the given class name, then
     * call {@link #newInstance(Class)} to create a new instance.
     *
     * @param className the given class name
     * @param &lt;T&gt;       the instance's type
     * @return a new instance for the given class name with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull String className) {
<span class="fc" id="L270">        return newInstance(className, null);</span>
    }

    /**
     * Returns a new instance for the given class name with the empty constructor, may be {@code null} if fails.
     * &lt;p&gt;
     * This method first uses {@link #classForName(String, ClassLoader)} to get the class of the given class name, then
     * call {@link #newInstance(Class)} to create a new instance.
     *
     * @param className the given class name
     * @param loader    the given class loader, may be {@code null} if loaded by the default loader
     * @param &lt;T&gt;       the instance's type
     * @return a new instance for the given class name with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull String className, @Nullable ClassLoader loader) {
<span class="fc" id="L285">        @Nullable Class&lt;?&gt; cls = classForName(className, loader);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (cls == null) {</span>
<span class="fc" id="L287">            return null;</span>
        }
<span class="fc" id="L289">        return newInstance(cls);</span>
    }

    /**
     * Returns a new instance for the given class with the empty constructor, may be {@code null} if fails.
     *
     * @param &lt;T&gt;  the instance's type
     * @param type the given class
     * @return a new instance for the given class with the empty constructor, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull Class&lt;?&gt; type) {
        try {
<span class="fc" id="L301">            Constructor&lt;?&gt; constructor = type.getConstructor();</span>
<span class="fc" id="L302">            return newInstance(constructor);</span>
<span class="fc" id="L303">        } catch (Exception e) {</span>
<span class="fc" id="L304">            return null;</span>
        }
    }

    /**
     * Creates a new instance with the given constructor and arguments, may be {@code null} if fails.
     *
     * @param constructor the given constructor
     * @param args        the given arguments
     * @param &lt;T&gt;         the instance's type
     * @return a new instance with the given constructor and arguments, may be {@code null} if fails
     */
    public static &lt;T&gt; @Nullable T newInstance(@Nonnull Constructor&lt;?&gt; constructor, Object @Nonnull ... args) {
        try {
<span class="fc" id="L318">            return Fs.as(constructor.newInstance(args));</span>
<span class="fc" id="L319">        } catch (Exception e) {</span>
<span class="fc" id="L320">            return null;</span>
        }
    }

    /**
     * Returns the array class whose component type is the specified type, may be {@code null} if fails. Note
     * {@link TypeVariable} and {@link WildcardType} are unsupported.
     *
     * @param componentType the specified component type
     * @return the array class whose component type is the specified type, may be {@code null} if fails
     */
    public static @Nullable Class&lt;?&gt; arrayClass(@Nonnull Type componentType) {
<span class="fc" id="L332">        return ArrayClassService.INST.arrayClass(componentType);</span>
    }

    /**
     * Returns the array class name whose component type is the specified type, may be {@code null} if fails.
     *
     * @param componentType the specified component type
     * @return the array class name whose component type is the specified type, may be {@code null} if fails
     */
    public static @Nullable String arrayClassName(@Nonnull Class&lt;?&gt; componentType) {
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (componentType.isArray()) {</span>
<span class="fc" id="L343">            return &quot;[&quot; + componentType.getName();</span>
        }
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (componentType.isPrimitive()) {</span>
            // No void[]
<span class="fc bfc" id="L347" title="All 2 branches covered.">            if (Objects.equals(componentType, void.class)) {</span>
<span class="fc" id="L348">                return null;</span>
            }
<span class="fc" id="L350">            return &quot;[&quot; + JvmKit.toDescriptor(componentType);</span>
        }
<span class="fc" id="L352">        return &quot;[L&quot; + componentType.getName() + &quot;;&quot;;</span>
    }

    /**
     * Returns the wrapper class if the given class is primitive, else return the given class itself.
     *
     * @param cls the given class
     * @return the wrapper class if the given class is primitive, else return the given class itself
     */
    public static @Nonnull Class&lt;?&gt; wrapperClass(@Nonnull Class&lt;?&gt; cls) {
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (!cls.isPrimitive()) {</span>
<span class="fc" id="L363">            return cls;</span>
        }
<span class="fc" id="L365">        return wrapperPrimitive(cls);</span>
    }

    private static Class&lt;?&gt; wrapperPrimitive(Class&lt;?&gt; cls) {
<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (Objects.equals(cls, boolean.class)) {</span>
<span class="fc" id="L370">            return Boolean.class;</span>
        }
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (Objects.equals(cls, byte.class)) {</span>
<span class="fc" id="L373">            return Byte.class;</span>
        }
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (Objects.equals(cls, short.class)) {</span>
<span class="fc" id="L376">            return Short.class;</span>
        }
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (Objects.equals(cls, char.class)) {</span>
<span class="fc" id="L379">            return Character.class;</span>
        }
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (Objects.equals(cls, int.class)) {</span>
<span class="fc" id="L382">            return Integer.class;</span>
        }
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (Objects.equals(cls, long.class)) {</span>
<span class="fc" id="L385">            return Long.class;</span>
        }
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (Objects.equals(cls, float.class)) {</span>
<span class="fc" id="L388">            return Float.class;</span>
        }
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (Objects.equals(cls, double.class)) {</span>
<span class="fc" id="L391">            return Double.class;</span>
        }
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (Objects.equals(cls, void.class)) {</span>
<span class="fc" id="L394">            return Void.class;</span>
        }
<span class="fc" id="L396">        throw new UnknownPrimitiveTypeException(cls);</span>
    }

    /**
     * Returns whether the current runtime exists the class specified by the given class name and loaded by the default
     * class loader.
     *
     * @param className the given class name
     * @return whether the current runtime exists the class specified by the given class name and loaded by the default
     * class loader
     */
    public static boolean classExists(@Nonnull String className) {
<span class="fc" id="L408">        return classExists(className, null);</span>
    }

    /**
     * Returns whether the current runtime exists the class specified by the given class name and loaded by the given
     * class loader.
     *
     * @param className the given class name
     * @param loader    the given class loader, may be {@code null} if loaded by the default loader
     * @return whether the current runtime exists the class specified by the given class name and loaded by the given
     * class loader
     */
    public static boolean classExists(@Nonnull String className, @Nullable ClassLoader loader) {
<span class="fc bfc" id="L421" title="All 2 branches covered.">        return classForName(className, loader) != null;</span>
    }

    /**
     * Returns the {@link Class} object whose name is the given name. This method is equivalent to
     * {@code classForName(name, null)}.
     *
     * @param name the given name of the class or interface
     * @return the {@link Class} object whose name is the given name, or {@code null} if loading fails
     * @see #classForName(String, ClassLoader)
     */
    public static @Nullable Class&lt;?&gt; classForName(@Nonnull String name) {
<span class="fc" id="L433">        return classForName(name, null);</span>
    }

    /**
     * Returns the {@link Class} object whose name is the given name. This method calls {@link Class#forName(String)} if
     * the given class loader is {@code null}, or {@link Class#forName(String, boolean, ClassLoader)} if not.
     *
     * @param name   the given name of the class or interface
     * @param loader the given class loader, may be {@code null}
     * @return the {@link Class} object whose name is the given name, or {@code null} if loading fails
     */
    public static @Nullable Class&lt;?&gt; classForName(@Nonnull String name, @Nullable ClassLoader loader) {
        try {
<span class="fc bfc" id="L446" title="All 2 branches covered.">            return loader == null ? Class.forName(name) : Class.forName(name, true, loader);</span>
<span class="fc" id="L447">        } catch (Exception e) {</span>
<span class="fc" id="L448">            return null;</span>
        }
    }

    /**
     * Returns a new {@link BytesClassLoader} instance.
     *
     * @return a new {@link BytesClassLoader} instance
     */
    public static @Nonnull BytesClassLoader newClassLoader() {
<span class="fc" id="L458">        return new BytesClassLoader();</span>
    }

    /**
     * Returns whether the given member is static.
     *
     * @param member the given member
     * @return whether the given member is static
     */
    public static boolean isStatic(@Nonnull Member member) {
<span class="fc" id="L468">        return Modifier.isStatic(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is public.
     *
     * @param member the given member
     * @return whether the given member is public
     */
    public static boolean isPublic(@Nonnull Member member) {
<span class="fc" id="L478">        return Modifier.isPublic(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is protected.
     *
     * @param member the given member
     * @return whether the given member is protected
     */
    public static boolean isProtected(@Nonnull Member member) {
<span class="fc" id="L488">        return Modifier.isProtected(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is private.
     *
     * @param member the given member
     * @return whether the given member is private
     */
    public static boolean isPrivate(@Nonnull Member member) {
<span class="fc" id="L498">        return Modifier.isPrivate(member.getModifiers());</span>
    }

    /**
     * Returns whether the given member is package-private (no modifies).
     *
     * @param member the given member
     * @return whether the given member is package-private (no modifies)
     */
    public static boolean isPackagePrivate(@Nonnull Member member) {
<span class="fc" id="L508">        int mod = member.getModifiers();</span>
<span class="fc bfc" id="L509" title="All 6 branches covered.">        return !Modifier.isPublic(mod) &amp;&amp; !Modifier.isProtected(mod) &amp;&amp; !Modifier.isPrivate(mod);</span>
    }

    /**
     * Returns whether the given class is static.
     *
     * @param cls the given class
     * @return whether the given class is static
     */
    public static boolean isStatic(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L519">        return Modifier.isStatic(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is public.
     *
     * @param cls the given class
     * @return whether the given class is public
     */
    public static boolean isPublic(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L529">        return Modifier.isPublic(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is protected.
     *
     * @param cls the given class
     * @return whether the given class is protected
     */
    public static boolean isProtected(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L539">        return Modifier.isProtected(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is private.
     *
     * @param cls the given class
     * @return whether the given class is private
     */
    public static boolean isPrivate(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L549">        return Modifier.isPrivate(cls.getModifiers());</span>
    }

    /**
     * Returns whether the given class is package-private (no modifies).
     *
     * @param cls the given class
     * @return whether the given class is package-private (no modifies)
     */
    public static boolean isPackagePrivate(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L559">        int mod = cls.getModifiers();</span>
<span class="fc bfc" id="L560" title="All 6 branches covered.">        return !Modifier.isPublic(mod) &amp;&amp; !Modifier.isProtected(mod) &amp;&amp; !Modifier.isPrivate(mod);</span>
    }

    /**
     * Returns whether the given member can be overridden (its owner class is no final, and itself is no final, no
     * static and no private).
     *
     * @param member the given member
     * @return whether the given member can be overridden (its owner class is no final, and itself is no final, no
     * static and no private)
     */
    public static boolean isOverridable(@Nonnull Member member) {
<span class="fc" id="L572">        int modifiers = member.getModifiers();</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">        if (!isOverridable(modifiers)) {</span>
<span class="fc" id="L574">            return false;</span>
        }
<span class="fc" id="L576">        Class&lt;?&gt; declaringClass = member.getDeclaringClass();</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        return !Modifier.isFinal(declaringClass.getModifiers());</span>
    }

    /**
     * Returns whether the given class can be overridden (no final, no static and no private).
     *
     * @param cls the given class
     * @return whether the given class can be overridden (no final, no static and no private)
     */
    public static boolean isOverridable(@Nonnull Class&lt;?&gt; cls) {
<span class="fc" id="L587">        int modifiers = cls.getModifiers();</span>
<span class="fc" id="L588">        return isOverridable(modifiers);</span>
    }

    private static boolean isOverridable(int mod) {
<span class="fc bfc" id="L592" title="All 2 branches covered.">        return !Modifier.isFinal(mod) &amp;&amp;</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">            !Modifier.isStatic(mod) &amp;&amp;</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">            !Modifier.isPrivate(mod);</span>
    }

    private ClassKit() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>