<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileRef.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.io.file</a> &gt; <span class="el_source">FileRef.java</span></div><h1>FileRef.java</h1><pre class="source lang-java linenums">package space.sunqian.common.io.file;

import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.common.Fs;
import space.sunqian.common.base.chars.CharsKit;
import space.sunqian.common.io.IORuntimeException;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URL;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.List;

/**
 * This interface represents a file reference used to retrieve information and manipulate the file.
 *
 * @author sunqian
 */
public interface FileRef {

    /**
     * Returns a new {@link FileRef} from the given path.
     *
     * @param path the given path
     * @return a new {@link FileRef} from the given path
     */
    static @Nonnull FileRef of(@Nonnull Path path) {
<span class="fc" id="L42">        return new FileRef() {</span>

            private File file;

            @Override
            public @Nonnull File getFile() {
<span class="fc bfc" id="L48" title="All 2 branches covered.">                if (file == null) {</span>
<span class="fc" id="L49">                    file = path.toFile();</span>
                }
<span class="fc" id="L51">                return file;</span>
            }

            @Override
            public @Nonnull Path getPath() {
<span class="fc" id="L56">                return path;</span>
            }
        };
    }

    /**
     * Returns a new {@link FileRef} from the given file.
     *
     * @param file the given file
     * @return a new {@link FileRef} from the given file
     */
    static @Nonnull FileRef of(@Nonnull File file) {
<span class="fc" id="L68">        return new FileRef() {</span>

            private Path path;

            @Override
            public @Nonnull File getFile() {
<span class="fc" id="L74">                return file;</span>
            }

            @Override
            public @Nonnull Path getPath() {
<span class="fc bfc" id="L79" title="All 2 branches covered.">                if (path == null) {</span>
<span class="fc" id="L80">                    path = file.toPath();</span>
                }
<span class="fc" id="L82">                return path;</span>
            }
        };
    }

    /**
     * Returns a new {@link FileRef} from the given path.
     *
     * @param path the given path
     * @return a new {@link FileRef} from the given path
     */
    static @Nonnull FileRef of(@Nonnull String path) {
<span class="fc" id="L94">        return of(Paths.get(path));</span>
    }

    /**
     * Returns a new {@link FileRef} from the given path string, or a sequence of strings.
     *
     * @param first the path string or initial part of the path string
     * @param more  additional path string or initial parts of the path string
     * @return a new {@link FileRef} from the given path string, or a sequence of strings
     */
    static @Nonnull FileRef of(@Nonnull String first, @Nonnull String @Nonnull ... more) {
<span class="fc" id="L105">        return of(Paths.get(first, more));</span>
    }

    /**
     * Returns a new {@link FileRef} from the given uri.
     *
     * @param uri the given uri
     * @return a new {@link FileRef} from the given uri
     */
    static @Nonnull FileRef of(@Nonnull URI uri) {
<span class="fc" id="L115">        return of(Paths.get(uri));</span>
    }

    /**
     * Returns a new {@link FileRef} from the given url.
     *
     * @param url the given url
     * @return a new {@link FileRef} from the given url
     * @throws IORuntimeException if the url is unsupported
     */
    static @Nonnull FileRef of(@Nonnull URL url) throws IORuntimeException {
        try {
<span class="fc" id="L127">            return of(Paths.get(url.toURI()));</span>
<span class="fc" id="L128">        } catch (Exception e) {</span>
<span class="fc" id="L129">            throw new IORuntimeException(e);</span>
        }
    }

    /**
     * Returns the {@link File} object related to this file reference.
     *
     * @return the {@link File} object related to this file reference
     */
    @Nonnull
    File getFile();

    /**
     * Returns the {@link Path} object related to this file reference.
     *
     * @return the {@link Path} object related to this file reference
     */
    @Nonnull
    Path getPath();

    /**
     * Returns the basic file attributes of the referenced file.
     *
     * @param linkOptions options indicating how symbolic links are handled, can be empty
     * @return the basic file attributes of the referenced file
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull BasicFileAttributes getBasicFileAttributes(
        @Nonnull LinkOption @Nonnull ... linkOptions
    ) throws IORuntimeException {
        try {
<span class="fc" id="L160">            return Files.readAttributes(getPath(), BasicFileAttributes.class, linkOptions);</span>
<span class="fc" id="L161">        } catch (Exception e) {</span>
<span class="fc" id="L162">            throw new IORuntimeException(e);</span>
        }
    }

    /**
     * Returns the content type of the referenced file. The return value is in form of {@code MIME}.
     *
     * @return the content type of the referenced file, or {@code null} if the content type cannot be determined
     * @throws IORuntimeException if any error occurs
     */
    default @Nullable String getContentType() throws IORuntimeException {
<span class="fc" id="L173">        return Fs.uncheck(</span>
<span class="fc" id="L174">            () -&gt; Files.probeContentType(getPath()),</span>
            IORuntimeException::new
        );
    }

    /**
     * Returns all bytes of the referenced file.
     *
     * @return a new array contains all bytes of the referenced file
     * @throws IORuntimeException if any error occurs
     */
    default byte @Nonnull [] readBytes() throws IORuntimeException {
        try {
<span class="fc" id="L187">            return Files.readAllBytes(getPath());</span>
<span class="fc" id="L188">        } catch (Exception e) {</span>
<span class="fc" id="L189">            throw new IORuntimeException(e);</span>
        }
    }

    /**
     * Returns string from the referenced file with the {@link CharsKit#defaultCharset()}.
     *
     * @return a string from the referenced file with the {@link CharsKit#defaultCharset()}
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull String readString() throws IORuntimeException {
<span class="fc" id="L200">        return readString(CharsKit.defaultCharset());</span>
    }

    /**
     * Returns string from the referenced file with the specified charset.
     *
     * @param charset the specified charset
     * @return a string from the referenced file with the specified charset
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull String readString(@Nonnull Charset charset) throws IORuntimeException {
<span class="fc" id="L211">        return new String(readBytes(), charset);</span>
    }

    /**
     * Returns all lines from the referenced file with the {@link CharsKit#defaultCharset()}. This method recognizes the
     * following as line separators:
     * &lt;ul&gt;
     *     &lt;li&gt;'\r\n'&lt;/li&gt;
     *     &lt;li&gt;'\n'&lt;/li&gt;
     *     &lt;li&gt;'\r'&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return all lines from the referenced file with the {@link CharsKit#defaultCharset()}
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull List&lt;String&gt; readLines() throws IORuntimeException {
<span class="fc" id="L227">        return readLines(CharsKit.defaultCharset());</span>
    }

    /**
     * Returns all lines from the referenced file with the specified charset. This method recognizes the following as
     * line separators:
     * &lt;ul&gt;
     *     &lt;li&gt;'\r\n'&lt;/li&gt;
     *     &lt;li&gt;'\n'&lt;/li&gt;
     *     &lt;li&gt;'\r'&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param charset the specified charset
     * @return all lines from the referenced file with the specified charset
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull List&lt;String&gt; readLines(@Nonnull Charset charset) throws IORuntimeException {
        try {
<span class="fc" id="L245">            return Files.readAllLines(getPath(), charset);</span>
<span class="fc" id="L246">        } catch (Exception e) {</span>
<span class="fc" id="L247">            throw new IORuntimeException(e);</span>
        }
    }

    /**
     * Write bytes to the referenced file with the open options. If no option is specified, this method creates a new
     * file or overwrites an existing file.
     *
     * @param bytes   the bytes to write
     * @param options the open options
     * @throws IORuntimeException if any error occurs
     */
    default void writeBytes(byte @Nonnull [] bytes, OpenOption @Nonnull ... options) throws IORuntimeException {
        try {
<span class="fc" id="L261">            Files.write(getPath(), bytes, options);</span>
<span class="fc" id="L262">        } catch (IOException e) {</span>
<span class="fc" id="L263">            throw new IORuntimeException(e);</span>
<span class="fc" id="L264">        }</span>
<span class="fc" id="L265">    }</span>

    /**
     * Write string to the referenced file with the {@link CharsKit#defaultCharset()} and open options. If no option is
     * specified, this method creates a new file or overwrites an existing file.
     *
     * @param string  the string to write
     * @param options the open options
     * @throws IORuntimeException if any error occurs
     */
    default void writeString(@Nonnull String string, OpenOption @Nonnull ... options) throws IORuntimeException {
<span class="fc" id="L276">        writeString(string, CharsKit.defaultCharset(), options);</span>
<span class="fc" id="L277">    }</span>

    /**
     * Write string to the referenced file with the specified charset and open options. If no option is specified, this
     * method creates a new file or overwrites an existing file.
     *
     * @param string  the string to write
     * @param charset the specified charset
     * @param options the open options
     * @throws IORuntimeException if any error occurs
     */
    default void writeString(@Nonnull String string, Charset charset, OpenOption @Nonnull ... options) throws IORuntimeException {
<span class="fc" id="L289">        writeBytes(string.getBytes(charset), options);</span>
<span class="fc" id="L290">    }</span>

    /**
     * Returns a new {@link FileInputStream} for reading the referenced file.
     *
     * @return a new {@link FileInputStream} for reading the referenced file
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull FileInputStream fileInputStream() throws IORuntimeException {
        try {
<span class="fc" id="L300">            return new FileInputStream(getFile());</span>
<span class="fc" id="L301">        } catch (FileNotFoundException e) {</span>
<span class="fc" id="L302">            throw new IORuntimeException(e);</span>
        }
    }

    /**
     * Returns a new {@link FileOutputStream} for writing the referenced file in overwrite mode. In overwrite mode, the
     * file's content will be overwritten starting from the beginning, and the file's length will be truncated or
     * extended to the number of bytes actually written.
     *
     * @return a new {@link FileOutputStream} for writing the referenced file in overwrite mode
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull FileOutputStream fileOutputStream() throws IORuntimeException {
<span class="fc" id="L315">        return fileOutputStream(false);</span>
    }

    /**
     * Returns a new {@link FileOutputStream} for writing the referenced file in the specified mode.
     * &lt;p&gt;
     * In overwrite mode, the file's content will be overwritten starting from the beginning, and the file's length will
     * be truncated or extended to the number of bytes actually written. Otherwise in append mode, new bytes will be
     * written starting at the end of the file, and the file's length will be extended by the number of bytes actually
     * written.
     *
     * @param append {@code true} for append mode, {@code false} for overwrite mode
     * @return a new {@link FileOutputStream} for writing the referenced file in the specified mode
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull FileOutputStream fileOutputStream(boolean append) throws IORuntimeException {
        try {
<span class="fc" id="L332">            return new FileOutputStream(getFile(), append);</span>
<span class="fc" id="L333">        } catch (FileNotFoundException e) {</span>
<span class="fc" id="L334">            throw new IORuntimeException(e);</span>
        }
    }

    /**
     * Opens and returns a new {@link InputStream} for reading the referenced file. If no option is specified, this
     * method opens the file for reading.
     * &lt;p&gt;
     * This method is equivalent to {@link Files#newInputStream(Path, OpenOption...)}.
     *
     * @param options options specifying how the file is opened
     * @return a new {@link InputStream} for reading the referenced file
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull InputStream newInputStream(
        @Nonnull OpenOption @Nonnull ... options
    ) throws IORuntimeException {
        try {
<span class="fc" id="L352">            return Files.newInputStream(getPath(), options);</span>
<span class="fc" id="L353">        } catch (Exception e) {</span>
<span class="fc" id="L354">            throw new IORuntimeException(e);</span>
        }
    }

    /**
     * Opens and returns a new {@link OutputStream} for writing the referenced file. If no option is specified, this
     * method opens the file for writing, creating the file if it doesn't exist, or truncating file to {@code 0} size if
     * it exists.
     * &lt;p&gt;
     * This method is equivalent to {@link Files#newOutputStream(Path, OpenOption...)}.
     *
     * @param options options specifying how the file is opened
     * @return a new {@link OutputStream} for writing the referenced file
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull OutputStream newOutputStream(
        @Nonnull OpenOption @Nonnull ... options
    ) throws IORuntimeException {
        try {
<span class="fc" id="L373">            return Files.newOutputStream(getPath(), options);</span>
<span class="fc" id="L374">        } catch (Exception e) {</span>
<span class="fc" id="L375">            throw new IORuntimeException(e);</span>
        }
    }

    /**
     * Opens and returns a new {@link FileChannel} for operating the referenced file.
     * &lt;p&gt;
     * This method is equivalent to {@link FileChannel#open(Path, OpenOption...)}.
     *
     * @param options options specifying how the file is opened
     * @return a new {@link FileChannel} for operating the referenced file
     * @throws IORuntimeException if any error occurs
     */
    default @Nonnull FileChannel newFileChannel(
        @Nonnull OpenOption @Nonnull ... options
    ) throws IORuntimeException {
        try {
<span class="fc" id="L392">            return FileChannel.open(getPath(), options);</span>
<span class="fc" id="L393">        } catch (IOException e) {</span>
<span class="fc" id="L394">            throw new IORuntimeException(e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>