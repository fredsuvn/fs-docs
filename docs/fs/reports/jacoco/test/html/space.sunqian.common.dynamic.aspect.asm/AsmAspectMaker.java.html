<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AsmAspectMaker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.dynamic.aspect.asm</a> &gt; <span class="el_source">AsmAspectMaker.java</span></div><h1>AsmAspectMaker.java</h1><pre class="source lang-java linenums">package space.sunqian.common.dynamic.aspect.asm;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.annotations.ThreadSafe;
import space.sunqian.common.Fs;
import space.sunqian.common.base.system.JvmKit;
import space.sunqian.common.dynamic.aspect.AspectException;
import space.sunqian.common.dynamic.aspect.AspectHandler;
import space.sunqian.common.dynamic.aspect.AspectMaker;
import space.sunqian.common.dynamic.aspect.AspectSpec;
import space.sunqian.common.dynamic.proxy.ProxyKit;
import space.sunqian.common.reflect.BytesClassLoader;
import space.sunqian.common.reflect.ClassKit;
import space.sunqian.common.third.asm.AsmKit;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong;

/**
 * The &lt;a href=&quot;https://asm.ow2.io/&quot;&gt;ASM&lt;/a&gt; implementation for {@link AspectMaker}. The runtime environment must have
 * asm package {@code org.objectweb.asm}.
 * &lt;p&gt;
 * This implementation uses inheritance to implement proxy, just like the keywords: {@code extends}. That means the
 * superclass, which is the advised class, cannot be {@code final} and must be inheritable, and must have an empty
 * constructor to ensure that the {@link AspectSpec#newInstance()} can execute correctly. And only the methods, which
 * can pass the {@link ProxyKit#isProxiable(Method)} and {@link AspectHandler#needsAspect(Method)}, can be advised.
 * &lt;p&gt;
 * Note the generated aspect class is {@code final}.
 *
 * @author sunqian
 */
@ThreadSafe
<span class="fc" id="L46">public class AsmAspectMaker implements AspectMaker {</span>

<span class="fc" id="L48">    private static final @Nonnull String HANDLER_NAME = JvmKit.toInternalName(AspectHandler.class);</span>
<span class="fc" id="L49">    private static final @Nonnull String HANDLER_DESCRIPTOR = JvmKit.toDescriptor(AspectHandler.class);</span>
<span class="fc" id="L50">    private static final @Nonnull String METHODS_DESCRIPTOR = JvmKit.toDescriptor(Method[].class);</span>
<span class="fc" id="L51">    private static final @Nonnull Method BEFORE_METHOD = Fs.uncheck(</span>
<span class="fc" id="L52">        () -&gt; AspectHandler.class.getMethod(&quot;beforeInvoking&quot;, Method.class, Object[].class, Object.class),</span>
        AsmAspectException::new
    );
<span class="fc" id="L55">    private static final @Nonnull String BEFORE_DESCRIPTOR = JvmKit.toDescriptor(BEFORE_METHOD);</span>
<span class="fc" id="L56">    private static final @Nonnull Method AFTER_METHOD = Fs.uncheck(</span>
<span class="fc" id="L57">        () -&gt; AspectHandler.class.getMethod(&quot;afterReturning&quot;, Object.class, Method.class, Object[].class, Object.class),</span>
        AsmAspectException::new
    );
<span class="fc" id="L60">    private static final @Nonnull String AFTER_DESCRIPTOR = JvmKit.toDescriptor(AFTER_METHOD);</span>
<span class="fc" id="L61">    private static final @Nonnull Method THROW_METHOD = Fs.uncheck(</span>
<span class="fc" id="L62">        () -&gt; AspectHandler.class.getMethod(&quot;afterThrowing&quot;, Throwable.class, Method.class, Object[].class, Object.class),</span>
        AsmAspectException::new
    );
<span class="fc" id="L65">    private static final @Nonnull String THROW_DESCRIPTOR = JvmKit.toDescriptor(THROW_METHOD);</span>
<span class="fc" id="L66">    private static final @Nonnull String METHOD_NAME = JvmKit.toInternalName(Method.class);</span>
<span class="fc" id="L67">    private static final @Nonnull String ARGS_NAME = JvmKit.toInternalName(Object[].class);</span>

<span class="fc" id="L69">    private static final @Nonnull AtomicLong classCounter = new AtomicLong();</span>

    @Override
    public @Nonnull AspectSpec make(
        @Nonnull Class&lt;?&gt; advisedClass,
        @Nonnull AspectHandler aspectHandler
    ) throws AsmAspectException {
        try {
<span class="fc" id="L77">            Package pkg = AsmAspectMaker.class.getPackage();</span>
            // aspect class internal name
<span class="fc" id="L79">            String aspectName = pkg.getName().replace('.', '/')</span>
<span class="fc" id="L80">                + &quot;/&quot; + AsmKit.generateClassSimpleName(classCounter.incrementAndGet());</span>
            // aspect class descriptor
            // String aspectDescriptor = &quot;L&quot; + aspectName + &quot;;&quot;;
<span class="fc" id="L83">            String advisedName = JvmKit.toInternalName(advisedClass);</span>
            // advised methods
<span class="fc" id="L85">            Map&lt;Method, AspectMethodInfo&gt; advisedMethodMap = new LinkedHashMap&lt;&gt;();</span>
            // IntVar methodCount = IntVar.of(0);
<span class="fc bfc" id="L87" title="All 2 branches covered.">            for (Method method : advisedClass.getMethods()) {</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">                if (!ProxyKit.isProxiable(method)) {</span>
<span class="fc" id="L89">                    continue;</span>
                }
<span class="fc bfc" id="L91" title="All 2 branches covered.">                if (!aspectHandler.needsAspect(method)) {</span>
<span class="fc" id="L92">                    continue;</span>
                }
<span class="fc" id="L94">                advisedMethodMap.put(</span>
                    method,
<span class="fc" id="L96">                    buildAspectMethodInfo(</span>
                        method
                        // advisedName,
                        // aspectDescriptor,
                        // methodCount.getAndIncrement()
                    )
                );
            }
<span class="fc" id="L104">            AspectClassInfo acInfo = new AspectClassInfo(</span>
                aspectName,
                // aspectDescriptor,
                advisedName,
<span class="fc" id="L108">                new ArrayList&lt;&gt;(advisedMethodMap.values())</span>
            );
<span class="fc" id="L110">            byte[] aspectClassBytes = generateAspectClass(acInfo);</span>
            // using new class loader to help collect unused classes
<span class="fc" id="L112">            BytesClassLoader loader = ClassKit.newClassLoader();</span>
<span class="fc" id="L113">            Class&lt;?&gt; aspectClass = loader.loadClass(null, aspectClassBytes);</span>
<span class="fc" id="L114">            return new AsmAspectSpec(</span>
                aspectClass,
                advisedClass,
                aspectHandler,
<span class="fc" id="L118">                advisedMethodMap.keySet().toArray(new Method[0])</span>
            );
<span class="fc" id="L120">        } catch (Exception e) {</span>
<span class="fc" id="L121">            throw new AsmAspectException(e);</span>
        }
    }

    private @Nonnull AspectMethodInfo buildAspectMethodInfo(
        @Nonnull Method method
        //@Nonnull String ownerName,
        //@Nonnull String aspectDescriptor,
        // int methodIndex
    ) {
<span class="fc" id="L131">        String descriptor = JvmKit.toDescriptor(method);</span>
<span class="fc" id="L132">        String signature = JvmKit.toSignature(method);</span>
<span class="fc" id="L133">        String[] exceptions = AsmKit.getExceptions(method);</span>
<span class="fc" id="L134">        return new AspectMethodInfo(</span>
            method,
            // ownerName,
            descriptor,
            signature,
            exceptions
        );
    }

    private byte @Nonnull [] generateAspectClass(@Nonnull AspectClassInfo pcInfo) throws Exception {
<span class="fc" id="L144">        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);</span>
<span class="fc" id="L145">        classWriter.visit(</span>
            Opcodes.V1_8,
            Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL | Opcodes.ACC_SUPER,
<span class="fc" id="L148">            pcInfo.aspectName,</span>
            null,
<span class="fc" id="L150">            pcInfo.advisedName,</span>
            null
        );
        {
<span class="fc" id="L154">            FieldVisitor visitor = classWriter.visitField(</span>
                Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL,
                &quot;handler&quot;,
                HANDLER_DESCRIPTOR,
                null,
                null
            );
<span class="fc" id="L161">            visitor.visitEnd();</span>
        }
        {
<span class="fc" id="L164">            FieldVisitor visitor = classWriter.visitField(</span>
                Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL,
                &quot;methods&quot;,
                METHODS_DESCRIPTOR,
                null,
                null
            );
<span class="fc" id="L171">            visitor.visitEnd();</span>
        }
        {
<span class="fc" id="L174">            MethodVisitor visitor = classWriter.visitMethod(</span>
                Opcodes.ACC_PUBLIC,
                AsmKit.CONSTRUCTOR_NAME,
                &quot;(&quot; + HANDLER_DESCRIPTOR + METHODS_DESCRIPTOR + &quot;)V&quot;,
                null,
                null
            );
<span class="fc" id="L181">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L182">            visitor.visitMethodInsn(</span>
                Opcodes.INVOKESPECIAL,
<span class="fc" id="L184">                pcInfo.advisedName,</span>
                AsmKit.CONSTRUCTOR_NAME,
                AsmKit.EMPTY_CONSTRUCTOR_DESCRIPTOR,
                false
            );
<span class="fc" id="L189">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L190">            visitor.visitVarInsn(Opcodes.ALOAD, 1);</span>
<span class="fc" id="L191">            visitor.visitFieldInsn(Opcodes.PUTFIELD, pcInfo.aspectName, &quot;handler&quot;, HANDLER_DESCRIPTOR);</span>
<span class="fc" id="L192">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L193">            visitor.visitVarInsn(Opcodes.ALOAD, 2);</span>
<span class="fc" id="L194">            visitor.visitFieldInsn(Opcodes.PUTFIELD, pcInfo.aspectName, &quot;methods&quot;, METHODS_DESCRIPTOR);</span>
<span class="fc" id="L195">            visitor.visitInsn(Opcodes.RETURN);</span>
<span class="fc" id="L196">            visitor.visitMaxs(0, 0);</span>
<span class="fc" id="L197">            visitor.visitEnd();</span>
        }
<span class="fc" id="L199">        int i = 0;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        for (AspectMethodInfo pmInfo : pcInfo.methods) {</span>
<span class="fc" id="L201">            generateAspectMethod(classWriter, pcInfo, pmInfo, i);</span>
<span class="fc" id="L202">            i++;</span>
<span class="fc" id="L203">        }</span>
<span class="fc" id="L204">        classWriter.visitEnd();</span>
<span class="fc" id="L205">        return classWriter.toByteArray();</span>
    }

    private void generateAspectMethod(
        @Nonnull ClassWriter classWriter,
        @Nonnull AspectClassInfo acInfo,
        @Nonnull AspectMethodInfo amInfo,
        int i
    ) {
<span class="fc" id="L214">        MethodVisitor visitor = classWriter.visitMethod(</span>
            Opcodes.ACC_PUBLIC,
<span class="fc" id="L216">            amInfo.method.getName(),</span>
<span class="fc" id="L217">            amInfo.descriptor,</span>
<span class="fc" id="L218">            amInfo.signature,</span>
<span class="fc" id="L219">            amInfo.exceptions</span>
        );

<span class="fc" id="L222">        boolean noReturn = Objects.equals(amInfo.method.getReturnType(), void.class);</span>
<span class="fc" id="L223">        int localSlots = AsmKit.countParamSlots(amInfo.method);</span>
<span class="fc" id="L224">        int handlerIndex = localSlots + 1;</span>
<span class="fc" id="L225">        int methodIndex = handlerIndex + 1;</span>
<span class="fc" id="L226">        int argsIndex = methodIndex + 1;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        int returnIndex = noReturn ? argsIndex : argsIndex + 1;</span>

<span class="fc" id="L229">        Label labelStart = new Label();</span>
<span class="fc" id="L230">        Label labelEnd = new Label();</span>
<span class="fc" id="L231">        Label labelHandler = new Label();</span>
<span class="fc" id="L232">        visitor.visitTryCatchBlock(labelStart, labelEnd, labelHandler, &quot;java/lang/Throwable&quot;);</span>
        {
            // Handler handler = this.handler;
            // Method method = this.methods[0];
<span class="fc" id="L236">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L237">            visitor.visitFieldInsn(Opcodes.GETFIELD, acInfo.aspectName, &quot;handler&quot;, HANDLER_DESCRIPTOR);</span>
<span class="fc" id="L238">            visitor.visitVarInsn(Opcodes.ASTORE, handlerIndex);</span>
<span class="fc" id="L239">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L240">            visitor.visitFieldInsn(Opcodes.GETFIELD, acInfo.aspectName, &quot;methods&quot;, METHODS_DESCRIPTOR);</span>
<span class="fc" id="L241">            AsmKit.visitConst(visitor, i);</span>
<span class="fc" id="L242">            visitor.visitInsn(Opcodes.AALOAD);</span>
<span class="fc" id="L243">            visitor.visitVarInsn(Opcodes.ASTORE, methodIndex);</span>
        }
        {
            // Object[] args = new Object[]{a};
<span class="fc" id="L247">            AsmKit.visitConst(visitor, amInfo.method.getParameterCount());</span>
<span class="fc" id="L248">            visitor.visitTypeInsn(Opcodes.ANEWARRAY, AsmKit.OBJECT_NAME);</span>
<span class="fc" id="L249">            int aIndex = 0;</span>
<span class="fc" id="L250">            int pIndex = 1;</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            for (Parameter parameter : amInfo.method.getParameters()) {</span>
                // args[i] = param[i]
<span class="fc" id="L253">                visitor.visitInsn(Opcodes.DUP);</span>
<span class="fc" id="L254">                AsmKit.visitConst(visitor, aIndex++);</span>
<span class="fc" id="L255">                AsmKit.visitLoad(visitor, parameter.getType(), pIndex);</span>
<span class="fc" id="L256">                AsmKit.wrapToObject(visitor, parameter.getType());</span>
<span class="fc" id="L257">                visitor.visitInsn(Opcodes.AASTORE);</span>
<span class="fc" id="L258">                pIndex += AsmKit.varSize(parameter.getType());</span>
            }
<span class="fc" id="L260">            visitor.visitVarInsn(Opcodes.ASTORE, argsIndex);</span>
        }
<span class="fc" id="L262">        visitor.visitLabel(labelStart);</span>
        {
            // aspectHandler.beforeInvoking(methods[0], args, this);
<span class="fc" id="L265">            visitor.visitVarInsn(Opcodes.ALOAD, handlerIndex);</span>
<span class="fc" id="L266">            visitor.visitVarInsn(Opcodes.ALOAD, methodIndex);</span>
<span class="fc" id="L267">            visitor.visitVarInsn(Opcodes.ALOAD, argsIndex);</span>
<span class="fc" id="L268">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L269">            visitor.visitMethodInsn(</span>
                Opcodes.INVOKEINTERFACE,
                HANDLER_NAME,
<span class="fc" id="L272">                BEFORE_METHOD.getName(),</span>
                BEFORE_DESCRIPTOR,
                true
            );
        }
        {
            // String ret = super.s1((String) args[0]);
<span class="fc" id="L279">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L280">            int pIndex = 0;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            for (Parameter parameter : amInfo.method.getParameters()) {</span>
                // get args
<span class="fc" id="L283">                visitor.visitVarInsn(Opcodes.ALOAD, argsIndex);</span>
<span class="fc" id="L284">                AsmKit.visitConst(visitor, pIndex++);</span>
                // get args[pIndex]
<span class="fc" id="L286">                visitor.visitInsn(Opcodes.AALOAD);</span>
<span class="fc" id="L287">                AsmKit.convertObjectTo(visitor, parameter.getType());</span>
            }
<span class="fc" id="L289">            visitor.visitMethodInsn(</span>
                Opcodes.INVOKESPECIAL,
<span class="fc" id="L291">                acInfo.advisedName,</span>
<span class="fc" id="L292">                amInfo.method.getName(),</span>
<span class="fc" id="L293">                amInfo.descriptor,</span>
                false
            );
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (!noReturn) {</span>
<span class="fc" id="L297">                AsmKit.wrapToObject(visitor, amInfo.method.getReturnType());</span>
<span class="fc" id="L298">                visitor.visitVarInsn(Opcodes.ASTORE, returnIndex);</span>
            }
        }
        {
            // return (String) aspectHandler.afterReturning(ret, methods[0], args, this);
<span class="fc" id="L303">            visitor.visitVarInsn(Opcodes.ALOAD, handlerIndex);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if (noReturn) {</span>
<span class="fc" id="L305">                visitor.visitInsn(Opcodes.ACONST_NULL);</span>
            } else {
<span class="fc" id="L307">                visitor.visitVarInsn(Opcodes.ALOAD, returnIndex);</span>
            }
<span class="fc" id="L309">            visitor.visitVarInsn(Opcodes.ALOAD, methodIndex);</span>
<span class="fc" id="L310">            visitor.visitVarInsn(Opcodes.ALOAD, argsIndex);</span>
<span class="fc" id="L311">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L312">            visitor.visitMethodInsn(</span>
                Opcodes.INVOKEINTERFACE,
                HANDLER_NAME,
<span class="fc" id="L315">                AFTER_METHOD.getName(),</span>
                AFTER_DESCRIPTOR,
                true
            );
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if (noReturn) {</span>
<span class="fc" id="L320">                visitor.visitInsn(Opcodes.POP);</span>
            } else {
<span class="fc" id="L322">                AsmKit.convertObjectTo(visitor, amInfo.method.getReturnType());</span>
            }
        }
<span class="fc" id="L325">        visitor.visitLabel(labelEnd);</span>
<span class="fc" id="L326">        AsmKit.visitReturn(visitor, amInfo.method.getReturnType(), false, false);</span>
<span class="fc" id="L327">        visitor.visitLabel(labelHandler);</span>
        {
            // return (String) aspectHandler.afterThrowing(ex, methods[0], args, this);
<span class="fc" id="L330">            List&lt;Object&gt; localNames = new ArrayList&lt;&gt;(</span>
<span class="fc" id="L331">                amInfo.method.getParameterCount() + 4 //+ (noReturn ? 0 : 1)</span>
            );
<span class="fc" id="L333">            localNames.add(acInfo.aspectName);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            for (Parameter parameter : amInfo.method.getParameters()) {</span>
<span class="fc" id="L335">                localNames.add(toFrameName(parameter.getType()));</span>
            }
<span class="fc" id="L337">            localNames.add(HANDLER_NAME);</span>
<span class="fc" id="L338">            localNames.add(METHOD_NAME);</span>
<span class="fc" id="L339">            localNames.add(ARGS_NAME);</span>
            // if (!noReturn) {
            //     localNames.add(toFrameName(amInfo.method.getReturnType()));
            // }
<span class="fc" id="L343">            visitor.visitFrame(</span>
                Opcodes.F_FULL,
<span class="fc" id="L345">                localNames.size(),</span>
<span class="fc" id="L346">                localNames.toArray(),</span>
                1,
                new Object[]{&quot;java/lang/Throwable&quot;}
            );
<span class="fc" id="L350">            int exIndex = argsIndex + 1;</span>
<span class="fc" id="L351">            visitor.visitVarInsn(Opcodes.ASTORE, exIndex);</span>
<span class="fc" id="L352">            visitor.visitVarInsn(Opcodes.ALOAD, handlerIndex);</span>
<span class="fc" id="L353">            visitor.visitVarInsn(Opcodes.ALOAD, exIndex);</span>
<span class="fc" id="L354">            visitor.visitVarInsn(Opcodes.ALOAD, methodIndex);</span>
<span class="fc" id="L355">            visitor.visitVarInsn(Opcodes.ALOAD, argsIndex);</span>
<span class="fc" id="L356">            visitor.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L357">            visitor.visitMethodInsn(</span>
                Opcodes.INVOKEINTERFACE,
                HANDLER_NAME,
<span class="fc" id="L360">                THROW_METHOD.getName(),</span>
                THROW_DESCRIPTOR,
                true
            );
<span class="fc bfc" id="L364" title="All 2 branches covered.">            if (noReturn) {</span>
<span class="fc" id="L365">                visitor.visitInsn(Opcodes.POP);</span>
            } else {
<span class="fc" id="L367">                AsmKit.convertObjectTo(visitor, amInfo.method.getReturnType());</span>
            }
<span class="fc" id="L369">            AsmKit.visitReturn(visitor, amInfo.method.getReturnType(), false, false);</span>
<span class="fc" id="L370">            visitor.visitMaxs(0, 0);</span>
<span class="fc" id="L371">            visitor.visitEnd();</span>
        }
<span class="fc" id="L373">    }</span>

    private @Nonnull Object toFrameName(Class&lt;?&gt; type) {
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (Objects.equals(type, boolean.class)</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">            || Objects.equals(type, byte.class)</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            || Objects.equals(type, short.class)</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            || Objects.equals(type, char.class)</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            || Objects.equals(type, int.class)) {</span>
<span class="fc" id="L381">            return Opcodes.INTEGER;</span>
        }
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (Objects.equals(type, long.class)) {</span>
<span class="fc" id="L384">            return Opcodes.LONG;</span>
        }
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if (Objects.equals(type, float.class)) {</span>
<span class="fc" id="L387">            return Opcodes.FLOAT;</span>
        }
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (Objects.equals(type, double.class)) {</span>
<span class="fc" id="L390">            return Opcodes.DOUBLE;</span>
        }
<span class="fc" id="L392">        return JvmKit.toInternalName(type);</span>
    }

    private static final class AspectClassInfo {

        private final @Nonnull String aspectName;
        // private final @Nonnull String aspectDescriptor;
        private final @Nonnull String advisedName;
        private final @Nonnull List&lt;AspectMethodInfo&gt; methods;

        private AspectClassInfo(
            @Nonnull String aspectName,
            //@Nonnull String aspectDescriptor,
            @Nonnull String advisedName,
            @Nonnull List&lt;AspectMethodInfo&gt; methods
<span class="fc" id="L407">        ) {</span>
<span class="fc" id="L408">            this.aspectName = aspectName;</span>
            // this.aspectDescriptor = aspectDescriptor;
<span class="fc" id="L410">            this.advisedName = advisedName;</span>
<span class="fc" id="L411">            this.methods = methods;</span>
<span class="fc" id="L412">        }</span>
    }

    private static final class AspectMethodInfo {

        private final @Nonnull Method method;
        // private final @Nonnull String ownerName;
        private final @Nonnull String descriptor;
        private final @Nullable String signature;
        private final @Nonnull String @Nullable [] exceptions;

        private AspectMethodInfo(
            @Nonnull Method method,
            //@Nonnull String ownerName,
            @Nonnull String descriptor,
            @Nullable String signature,
            @Nonnull String @Nullable [] exceptions
<span class="fc" id="L429">        ) {</span>
<span class="fc" id="L430">            this.method = method;</span>
            // this.ownerName = ownerName;
<span class="fc" id="L432">            this.descriptor = descriptor;</span>
<span class="fc" id="L433">            this.signature = signature;</span>
<span class="fc" id="L434">            this.exceptions = exceptions;</span>
<span class="fc" id="L435">        }</span>
    }

    private static final class AsmAspectSpec implements AspectSpec {

        private final @Nonnull Class&lt;?&gt; aspectClass;
        private final @Nonnull Class&lt;?&gt; advisedClass;
        private final @Nonnull AspectHandler aspectHandler;
        private final @Nonnull Method @Nonnull [] methods;

        private AsmAspectSpec(
            @Nonnull Class&lt;?&gt; aspectClass,
            @Nonnull Class&lt;?&gt; advisedClass,
            @Nonnull AspectHandler aspectHandler,
            @Nonnull Method @Nonnull [] methods
<span class="fc" id="L450">        ) {</span>
<span class="fc" id="L451">            this.aspectClass = aspectClass;</span>
<span class="fc" id="L452">            this.advisedClass = advisedClass;</span>
<span class="fc" id="L453">            this.aspectHandler = aspectHandler;</span>
<span class="fc" id="L454">            this.methods = methods;</span>
<span class="fc" id="L455">        }</span>

        @Override
        public &lt;T&gt; @Nonnull T newInstance() throws AsmAspectException {
<span class="fc" id="L459">            return Fs.uncheck(() -&gt; {</span>
<span class="fc" id="L460">                Constructor&lt;?&gt; constructor = aspectClass.getConstructor(AspectHandler.class, Method[].class);</span>
<span class="fc" id="L461">                return Fs.as(constructor.newInstance(aspectHandler, methods));</span>
            }, AsmAspectException::new);
        }

        @Override
        public @Nonnull Class&lt;?&gt; aspectClass() {
<span class="fc" id="L467">            return aspectClass;</span>
        }

        @Override
        public @Nonnull Class&lt;?&gt; advisedClass() {
<span class="fc" id="L472">            return advisedClass;</span>
        }

        @Override
        public @Nonnull AspectHandler aspectHandler() {
<span class="fc" id="L477">            return aspectHandler;</span>
        }
    }

    /**
     * This exception is the sub-exception of {@link AspectException} for &lt;a href=&quot;https://asm.ow2.io/&quot;&gt;ASM&lt;/a&gt; proxy
     * implementation.
     *
     * @author sunqian
     */
    public static class AsmAspectException extends AspectException {
        /**
         * Constructs with the cause.
         *
         * @param cause the cause
         */
        public AsmAspectException(@Nullable Throwable cause) {
<span class="fc" id="L494">            super(cause);</span>
<span class="fc" id="L495">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>