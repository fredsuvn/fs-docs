<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Checker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.base</a> &gt; <span class="el_source">Checker.java</span></div><h1>Checker.java</h1><pre class="source lang-java linenums">package space.sunqian.common.base;

import space.sunqian.annotations.Nonnull;
import space.sunqian.common.base.exception.UnreachablePointException;

import java.util.NoSuchElementException;

/**
 * This class is the core utilities for checking and verifying parameters.
 *
 * @author sunqian
 */
public class Checker {

    /**
     * Checks whether the given {@code off} and {@code len} are out of the range: {@code [0, capacity)}. Its logic is
     * the same as the following code:
     * &lt;pre&gt;{@code
     * if (off &lt; 0 || len &lt; 0 || off + len &gt; capacity) {
     *     throw new IndexOutOfBoundsException(&quot;off=&quot; + off + &quot;, len=&quot; + len + &quot;, capacity=&quot; + capacity);
     * }
     * }&lt;/pre&gt;
     *
     * @param off      the given offset
     * @param len      the given length
     * @param capacity the given capacity which is typically represents the length of the range
     * @throws IndexOutOfBoundsException if the given {@code off} and {@code len} are out of the range:
     *                                   {@code [0, capacity)}
     */
    public static void checkOffLen(int off, int len, int capacity) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L31" title="All 6 branches covered.">        if (off &lt; 0 || len &lt; 0 || off + len &gt; capacity) {</span>
<span class="fc" id="L32">            throw new IndexOutOfBoundsException(&quot;off=&quot; + off + &quot;, len=&quot; + len + &quot;, capacity=&quot; + capacity);</span>
        }
<span class="fc" id="L34">    }</span>

    /**
     * Checks whether the given {@code off} and {@code len} are out of the range: {@code [0, capacity)}. Its logic is
     * the same as the following code:
     * &lt;pre&gt;{@code
     * if (off &lt; 0 || len &lt; 0 || off + len &gt; capacity) {
     *     throw new IndexOutOfBoundsException(&quot;off=&quot; + off + &quot;, len=&quot; + len + &quot;, capacity=&quot; + capacity);
     * }
     * }&lt;/pre&gt;
     *
     * @param off      the given offset
     * @param len      the given length
     * @param capacity the given capacity which is typically represents the length of the range
     * @throws IndexOutOfBoundsException if the given {@code off} and {@code len} are out of the range:
     *                                   {@code [0, capacity)}
     */
    public static void checkOffLen(long off, long len, long capacity) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L52" title="All 6 branches covered.">        if (off &lt; 0 || len &lt; 0 || len &gt; capacity - off) {</span>
<span class="fc" id="L53">            throw new IndexOutOfBoundsException(&quot;off=&quot; + off + &quot;, len=&quot; + len + &quot;, capacity=&quot; + capacity);</span>
        }
<span class="fc" id="L55">    }</span>

    /**
     * Checks whether the given {@code start} and {@code end} are out of the range: {@code [0, capacity)}. Its logic is
     * the same as the following code:
     * &lt;pre&gt;{@code
     * if (start &lt; 0 || end &lt; start || end &gt; capacity) {
     *     throw new IndexOutOfBoundsException(&quot;start=&quot; + start + &quot;, end=&quot; + end + &quot;, capacity=&quot; + capacity);
     * }
     * }&lt;/pre&gt;
     *
     * @param start    the given start, typically inclusive
     * @param end      the given end, typically exclusive
     * @param capacity the given capacity which is typically represents the length of the range
     * @throws IndexOutOfBoundsException if the given {@code start} and {@code end} are out of the range:
     *                                   {@code [0, capacity)}
     */
    public static void checkStartEnd(int start, int end, int capacity) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L73" title="All 6 branches covered.">        if (start &lt; 0 || end &lt; start || end &gt; capacity) {</span>
<span class="fc" id="L74">            throw new IndexOutOfBoundsException(&quot;start=&quot; + start + &quot;, end=&quot; + end + &quot;, capacity=&quot; + capacity);</span>
        }
<span class="fc" id="L76">    }</span>

    /**
     * Checks whether the given {@code start} and {@code end} are out of the range: {@code [0, capacity)}. Its logic is
     * the same as the following code:
     * &lt;pre&gt;{@code
     * if (start &lt; 0 || end &lt; start || end &gt; capacity) {
     *     throw new IndexOutOfBoundsException(&quot;start=&quot; + start + &quot;, end=&quot; + end + &quot;, capacity=&quot; + capacity);
     * }
     * }&lt;/pre&gt;
     *
     * @param start    the given start, typically inclusive
     * @param end      the given end, typically exclusive
     * @param capacity the given capacity which is typically represents the length of the range
     * @throws IndexOutOfBoundsException if the given {@code start} and {@code end} are out of the range:
     *                                   {@code [0, capacity)}
     */
    public static void checkStartEnd(long start, long end, long capacity) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L94" title="All 6 branches covered.">        if (start &lt; 0 || end &lt; start || end &gt; capacity) {</span>
<span class="fc" id="L95">            throw new IndexOutOfBoundsException(&quot;start=&quot; + start + &quot;, end=&quot; + end + &quot;, capacity=&quot; + capacity);</span>
        }
<span class="fc" id="L97">    }</span>

    /**
     * Checks whether the given expression is {@code true}, if it is not, throws a new {@link IllegalArgumentException}
     * with the given message.
     *
     * @param expr    the given expression
     * @param message the given message
     * @throws IllegalArgumentException if the given expression is {@code false}
     */
    public static void checkArgument(
        boolean expr, @Nonnull CharSequence message
    ) throws IllegalArgumentException {
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (!expr) {</span>
<span class="fc" id="L111">            throw new IllegalArgumentException(message.toString());</span>
        }
<span class="fc" id="L113">    }</span>

    /**
     * Checks whether the given expression is {@code true}, if it is not, throws a new {@link IllegalStateException}
     * with the given message.
     *
     * @param expr    the given expression
     * @param message the given message
     * @throws IllegalStateException if the given expression is {@code false}
     */
    public static void checkState(
        boolean expr, @Nonnull CharSequence message
    ) throws IllegalStateException {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (!expr) {</span>
<span class="fc" id="L127">            throw new IllegalStateException(message.toString());</span>
        }
<span class="fc" id="L129">    }</span>

    /**
     * Checks whether the given expression is {@code true}, if it is not, throws a new
     * {@link UnsupportedOperationException} with the given message.
     *
     * @param expr    the given expression
     * @param message the given message
     * @throws UnsupportedOperationException if the given expression is {@code false}
     */
    public static void checkSupported(
        boolean expr, @Nonnull CharSequence message
    ) throws UnsupportedOperationException {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (!expr) {</span>
<span class="fc" id="L143">            throw new UnsupportedOperationException(message.toString());</span>
        }
<span class="fc" id="L145">    }</span>

    /**
     * Checks whether the given expression is {@code true}, if it is not, throws a new {@link NoSuchElementException}
     * with the given message.
     *
     * @param expr    the given expression
     * @param message the given message
     * @throws NoSuchElementException if the given expression is {@code false}
     */
    public static void checkElement(
        boolean expr, @Nonnull CharSequence message
    ) throws NoSuchElementException {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (!expr) {</span>
<span class="fc" id="L159">            throw new NoSuchElementException(message.toString());</span>
        }
<span class="fc" id="L161">    }</span>

    /**
     * Checks whether the given expression is {@code true}, if it is not, throws a new {@link UnreachablePointException}
     * with the given message.
     *
     * @param expr    the given expression
     * @param message the given message
     * @throws UnreachablePointException if the given expression is {@code false}
     */
    public static void checkReachable(
        boolean expr, @Nonnull CharSequence message
    ) throws UnreachablePointException {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (!expr) {</span>
<span class="fc" id="L175">            throw new UnreachablePointException(message.toString());</span>
        }
<span class="fc" id="L177">    }</span>

    /**
     * Returns whether the given position is between the start boundary (inclusive) and the end boundary (exclusive).
     * Its logic is the same as the following code:
     * &lt;pre&gt;{@code
     * return pos &gt;= startBound &amp;&amp; pos &lt; endBound;
     * }&lt;/pre&gt;
     *
     * @param pos        the given position to be compared
     * @param startBound the start boundary, inclusive
     * @param endBound   the end boundary, exclusive
     * @return whether the given position is between the start boundary (inclusive) and the end boundary (exclusive)
     */
    public static boolean isInBounds(int pos, int startBound, int endBound) {
<span class="fc bfc" id="L192" title="All 4 branches covered.">        return pos &gt;= startBound &amp;&amp; pos &lt; endBound;</span>
    }

    /**
     * Returns whether the given position is between the start boundary (inclusive) and the end boundary (exclusive).
     * Its logic is the same as the following code:
     * &lt;pre&gt;{@code
     * return pos &gt;= startBound &amp;&amp; pos &lt; endBound;
     * }&lt;/pre&gt;
     *
     * @param pos        the given position to be compared
     * @param startBound the start boundary, inclusive
     * @param endBound   the end boundary, exclusive
     * @return whether the given position is between the start boundary (inclusive) and the end boundary (exclusive)
     */
    public static boolean isInBounds(long pos, long startBound, long endBound) {
<span class="fc bfc" id="L208" title="All 4 branches covered.">        return pos &gt;= startBound &amp;&amp; pos &lt; endBound;</span>
    }

    /**
     * Checks whether the given position is between the start boundary (inclusive) and the end boundary (exclusive). Its
     * logic is the same as the following code:
     * &lt;pre&gt;{@code
     * if (!(pos &gt;= startBound &amp;&amp; pos &lt; endBound)) {
     *     throw new IndexOutOfBoundsException(
     *         &quot;Out of bounds for &quot; + pos + &quot; in [&quot; + startPos + &quot;, &quot; + endPos + &quot;).&quot;
     *     );
     * }
     * }&lt;/pre&gt;
     *
     * @param pos        the given position to be compared
     * @param startBound the start boundary, inclusive
     * @param endBound   the end boundary, exclusive
     * @throws IndexOutOfBoundsException if the given position is out of the specified bounds
     */
    public static void checkInBounds(
        int pos, int startBound, int endBound
    ) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (!isInBounds(pos, startBound, endBound)) {</span>
<span class="fc" id="L231">            throw new IndexOutOfBoundsException(</span>
                &quot;Out of bounds for &quot; + pos + &quot; in [&quot; + startBound + &quot;, &quot; + endBound + &quot;).&quot;
            );
        }
<span class="fc" id="L235">    }</span>

    /**
     * Checks whether the given position is between the start boundary (inclusive) and the end boundary (exclusive). Its
     * logic is the same as the following code:
     * &lt;pre&gt;{@code
     * if (!(pos &gt;= startBound &amp;&amp; pos &lt; endBound)) {
     *     throw new IndexOutOfBoundsException(
     *         &quot;Out of bounds for &quot; + pos + &quot; in [&quot; + startPos + &quot;, &quot; + endPos + &quot;).&quot;
     *     );
     * }
     * }&lt;/pre&gt;
     *
     * @param pos        the given position to be compared
     * @param startBound the start boundary, inclusive
     * @param endBound   the end boundary, exclusive
     * @throws IndexOutOfBoundsException if the given position is out of the specified bounds
     */
    public static void checkInBounds(
        long pos, long startBound, long endBound
    ) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (!isInBounds(pos, startBound, endBound)) {</span>
<span class="fc" id="L257">            throw new IndexOutOfBoundsException(</span>
                &quot;Out of bounds for &quot; + pos + &quot; in [&quot; + startBound + &quot;, &quot; + endBound + &quot;).&quot;
            );
        }
<span class="fc" id="L261">    }</span>

    /**
     * Returns whether the given range, starting at the given start position (inclusive) and ending at the given end
     * position (exclusive), is between the start boundary (inclusive) and the end boundary (exclusive). Its logic is
     * the same as the following code:
     * &lt;pre&gt;{@code
     * return start &gt;= startBound &amp;&amp; end &lt;= endBound &amp;&amp; start &lt;= end;
     * }&lt;/pre&gt;
     *
     * @param start      the given start position of the range, inclusive
     * @param end        the given end position of the range, exclusive
     * @param startBound the start boundary, inclusive
     * @param endBound   the end boundary, exclusive
     * @return whether the given range is between the start boundary (inclusive) and the end boundary (exclusive)
     */
    public static boolean isInBounds(int start, int end, int startBound, int endBound) {
<span class="fc bfc" id="L278" title="All 6 branches covered.">        return start &gt;= startBound &amp;&amp; end &lt;= endBound &amp;&amp; start &lt;= end;</span>
    }

    /**
     * Returns whether the given range, starting at the given start position (inclusive) and ending at the given end
     * position (exclusive), is between the start boundary (inclusive) and the end boundary (exclusive). Its logic is
     * the same as the following code:
     * &lt;pre&gt;{@code
     * return start &gt;= startBound &amp;&amp; end &lt;= endBound &amp;&amp; start &lt;= end;
     * }&lt;/pre&gt;
     *
     * @param start      the given start position of the range, inclusive
     * @param end        the given end position of the range, exclusive
     * @param startBound the start boundary, inclusive
     * @param endBound   the end boundary, exclusive
     * @return whether the given range is between the start boundary (inclusive) and the end boundary (exclusive)
     */
    public static boolean isInBounds(long start, long end, long startBound, long endBound) {
<span class="fc bfc" id="L296" title="All 6 branches covered.">        return start &gt;= startBound &amp;&amp; end &lt;= endBound &amp;&amp; start &lt;= end;</span>
    }

    /**
     * Checks whether the given range, starting at the given start position (inclusive) and ending at the given end
     * position (exclusive), is between the start boundary (inclusive) and the end boundary (exclusive). Its logic is
     * the same as the following code:
     * &lt;pre&gt;{@code
     * if (!(start &gt;= startBound &amp;&amp; end &lt;= endBound &amp;&amp; start &lt;= end)) {
     *     throw new IndexOutOfBoundsException(
     *         &quot;Out of bounds for [&quot; + start + &quot;, &quot; + end + &quot;) in [&quot; + startBound + &quot;, &quot; + endBound + &quot;).&quot;
     *     );
     * }
     * }&lt;/pre&gt;
     *
     * @param start      the given start position of the range, inclusive
     * @param end        the given end position of the range, exclusive
     * @param startBound the start boundary, inclusive
     * @param endBound   the end boundary, exclusive
     * @throws IndexOutOfBoundsException if the given range is out of the specified bounds
     */
    public static void checkInBounds(
        int start, int end, int startBound, int endBound) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (!isInBounds(start, end, startBound, endBound)) {</span>
<span class="fc" id="L320">            throw new IndexOutOfBoundsException(</span>
                &quot;Out of bounds for [&quot; + start + &quot;, &quot; + end + &quot;) in [&quot; + startBound + &quot;, &quot; + endBound + &quot;).&quot;
            );
        }
<span class="fc" id="L324">    }</span>

    /**
     * Checks whether the given range, starting at the given start position (inclusive) and ending at the given end
     * position (exclusive), is between the start boundary (inclusive) and the end boundary (exclusive). Its logic is
     * the same as the following code:
     * &lt;pre&gt;{@code
     * if (!(start &gt;= startBound &amp;&amp; end &lt;= endBound &amp;&amp; start &lt;= end)) {
     *     throw new IndexOutOfBoundsException(
     *         &quot;Out of bounds for [&quot; + start + &quot;, &quot; + end + &quot;) in [&quot; + startBound + &quot;, &quot; + endBound + &quot;).&quot;
     *     );
     * }
     * }&lt;/pre&gt;
     *
     * @param start      the given start position of the range, inclusive
     * @param end        the given end position of the range, exclusive
     * @param startBound the start boundary, inclusive
     * @param endBound   the end boundary, exclusive
     * @throws IndexOutOfBoundsException if the given range is out of the specified bounds
     */
    public static void checkInBounds(
        long start, long end, long startBound, long endBound) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (!isInBounds(start, end, startBound, endBound)) {</span>
<span class="fc" id="L347">            throw new IndexOutOfBoundsException(</span>
                &quot;Out of bounds for [&quot; + start + &quot;, &quot; + end + &quot;) in [&quot; + startBound + &quot;, &quot; + endBound + &quot;).&quot;
            );
        }
<span class="fc" id="L351">    }</span>

    private Checker() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>