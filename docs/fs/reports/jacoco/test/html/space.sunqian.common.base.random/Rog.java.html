<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Rog.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.base.random</a> &gt; <span class="el_source">Rog.java</span></div><h1>Rog.java</h1><pre class="source lang-java linenums">package space.sunqian.common.base.random;

import space.sunqian.annotations.Nonnull;
import space.sunqian.annotations.Nullable;
import space.sunqian.common.base.Checker;
import space.sunqian.common.Fs;
import space.sunqian.common.base.exception.UnreachablePointException;

import java.util.ArrayList;
import java.util.List;
import java.util.function.LongSupplier;
import java.util.function.Supplier;

/**
 * The Random Object Generator, to produce random objects. The usage is simple:
 * &lt;pre&gt;{@code
 * Rog&lt;String&gt; rog = Rog.newBuilder()
 *     .weight(10, &quot;a&quot;)
 *     .weight(10, &quot;b&quot;)
 *     .build();
 * String randomString = rog.next();
 * }&lt;/pre&gt;
 *
 * @author sunqian
 */
public interface Rog&lt;T&gt; {

    /**
     * Returns a new builder for generating a new {@link Rog} instances.
     *
     * @param &lt;T&gt; the type of the generated object
     * @return a new builder for generating a new {@link Rog} instances
     */
    static &lt;T&gt; @Nonnull Builder&lt;T&gt; newBuilder() {
<span class="fc" id="L35">        return new Builder&lt;&gt;();</span>
    }

    /**
     * Returns next random object.
     *
     * @return next random object
     */
    T next();

    /**
     * Builder for generating a new {@link Rog} instance.
     * &lt;p&gt;
     * This Builder generates {@link Rog} by setting {@code rng} (random number generator) and weights. For example:
     * &lt;pre&gt;{@code
     * Rog&lt;String&gt; rog = Rog.newBuilder()
     *     .weight(20, &quot;a&quot;)       // 20% to generate &quot;a&quot;
     *     .weight(80, () -&gt; &quot;b&quot;) // 80% to generate &quot;b&quot;
     *     .rng(Rng.newRng())
     *     .build();
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * The probability of hitting the object or supplier associated with each weight is given by:
     * {@code weight / sum(weights)}. The {@code rng} provides the random long value, which is used to calculate the
     * hitting probability. If the {@code rng} is not set, {@link Rng#newRng()} is used.
     * &lt;p&gt;
     * Note that the sum of weights can not overflow the {@link Long#MAX_VALUE}.
     *
     * @param &lt;T&gt; the type of the random objects
     * @author sunqian
     */
<span class="fc" id="L66">    class Builder&lt;T&gt; {</span>

<span class="fc" id="L68">        private final @Nonnull List&lt;@Nonnull Weight&lt;T&gt;&gt; weights = new ArrayList&lt;&gt;();</span>
        private @Nullable LongSupplier rng;

        /**
         * Add a weight and its corresponding object.
         *
         * @param weight the weight, cannot be negative
         * @param obj    the object corresponding to the weight
         * @param &lt;T1&gt;   the type of the object
         * @return this builder
         */
        public &lt;T1&gt; @Nonnull Builder&lt;T1&gt; weight(long weight, T obj) throws IllegalArgumentException {
<span class="fc" id="L80">            return weight(weight, () -&gt; obj);</span>
        }

        /**
         * Add a weight and its corresponding supplier.
         *
         * @param weight   the weight, cannot be negative
         * @param supplier the supplier corresponding to the weight
         * @param &lt;T1&gt;     the type of the generated object
         * @return this builder
         */
        public &lt;T1&gt; @Nonnull Builder&lt;T1&gt; weight(
            long weight, @Nonnull Supplier&lt;T&gt; supplier
        ) throws IllegalArgumentException {
<span class="fc bfc" id="L94" title="All 2 branches covered.">            Checker.checkArgument(weight &gt;= 0, &quot;weight must be non-negative&quot;);</span>
<span class="fc" id="L95">            weights.add(new Weight&lt;&gt;(weight, supplier));</span>
<span class="fc" id="L96">            return Fs.as(this);</span>
        }

        /**
         * Set the random number generator. If this is not set, {@link Rng#newRng()} will be used.
         *
         * @param rng  the random number generator
         * @param &lt;T1&gt; the type of the generated object
         * @return this builder
         */
        public &lt;T1&gt; @Nonnull Builder&lt;T1&gt; rng(@Nonnull LongSupplier rng) {
<span class="fc" id="L107">            this.rng = rng;</span>
<span class="fc" id="L108">            return Fs.as(this);</span>
        }

        /**
         * Builds and returns a new {@link Rog} instance with the added weights, objects and suppliers.
         *
         * @param &lt;T1&gt; the type of the generated object
         * @return a new {@link Rog} instance with the added weights, objects and suppliers
         */
        public &lt;T1&gt; @Nonnull Rog&lt;T1&gt; build() {
<span class="fc bfc" id="L118" title="All 2 branches covered.">            return Fs.as(</span>
<span class="fc" id="L119">                new RogImpl&lt;&gt;(rng == null ? Rng.newRng() : rng, weights)</span>
            );
        }

        private static final class RogImpl&lt;T&gt; implements Rog&lt;T&gt; {

            private final @Nonnull LongSupplier rng;
            private final @Nonnull WeightNode&lt;T&gt;[] nodes;
            private final long totalWeight;

            @SuppressWarnings(&quot;unchecked&quot;)
            RogImpl(
                @Nonnull LongSupplier rng,
                @Nonnull List&lt;@Nonnull Weight&lt;T&gt;&gt; weights
<span class="fc" id="L133">            ) {</span>
<span class="fc" id="L134">                this.rng = rng;</span>
<span class="fc" id="L135">                List&lt;WeightNode&lt;T&gt;&gt; nodes = new ArrayList&lt;&gt;(weights.size());</span>
<span class="fc" id="L136">                long totalScore = 0;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">                for (Weight&lt;T&gt; weight : weights) {</span>
<span class="fc" id="L138">                    long from = totalScore;</span>
<span class="fc" id="L139">                    totalScore += weight.weight;</span>
<span class="fc" id="L140">                    long to = totalScore;</span>
<span class="fc" id="L141">                    nodes.add(new WeightNode&lt;&gt;(weight.supplier, from, to));</span>
<span class="fc" id="L142">                }</span>
<span class="fc" id="L143">                this.nodes = nodes.toArray(new WeightNode[0]);</span>
<span class="fc" id="L144">                this.totalWeight = totalScore;</span>
<span class="fc" id="L145">            }</span>

            @Override
            public T next() {
<span class="fc" id="L149">                long score = Math.abs(rng.getAsLong()) % totalWeight;</span>
<span class="fc" id="L150">                WeightNode&lt;T&gt; weight = getWeight(score);</span>
<span class="fc" id="L151">                return weight.supplier.get();</span>
            }

            private @Nonnull WeightNode&lt;T&gt; getWeight(long score) {
<span class="fc" id="L155">                int index = binarySearch(score);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">                if (index &lt; 0) {</span>
<span class="fc" id="L157">                    throw new UnreachablePointException(&quot;Weight not found by score: &quot; + score + &quot;.&quot;);</span>
                }
<span class="fc" id="L159">                return nodes[index];</span>
            }

            private int binarySearch(long score) {
<span class="fc" id="L163">                int left = 0;</span>
<span class="fc" id="L164">                int right = nodes.length - 1;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">                while (left &lt;= right) {</span>
                    // int mid = (left + right) / 2;
<span class="fc" id="L167">                    int mid = (left + right) &gt;&gt;&gt; 1;</span>
<span class="fc" id="L168">                    WeightNode&lt;T&gt; weight = nodes[mid];</span>
<span class="fc" id="L169">                    long compare = compare(score, weight);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                    if (compare == 0) {</span>
<span class="fc" id="L171">                        return mid;</span>
                    }
<span class="fc bfc" id="L173" title="All 2 branches covered.">                    if (compare &gt; 0) {</span>
<span class="fc" id="L174">                        left = mid + 1;</span>
                    } else {
<span class="fc" id="L176">                        right = mid - 1;</span>
                    }
<span class="fc" id="L178">                }</span>
<span class="fc" id="L179">                return -1;</span>
            }

            private long compare(long next, WeightNode&lt;T&gt; node) {
<span class="fc bfc" id="L183" title="All 2 branches covered.">                if (next &lt; node.from) {</span>
<span class="fc" id="L184">                    return -1;</span>
                }
<span class="fc bfc" id="L186" title="All 2 branches covered.">                if (next &gt;= node.to) {</span>
<span class="fc" id="L187">                    return 1;</span>
                }
<span class="fc" id="L189">                return 0;</span>
            }

        }

        private static final class Weight&lt;T&gt; {

            private final long weight;
            private final @Nonnull Supplier&lt;T&gt; supplier;

<span class="fc" id="L199">            private Weight(long weight, @Nonnull Supplier&lt;T&gt; supplier) {</span>
<span class="fc" id="L200">                this.weight = weight;</span>
<span class="fc" id="L201">                this.supplier = supplier;</span>
<span class="fc" id="L202">            }</span>
        }

        private static final class WeightNode&lt;T&gt; {

            private final @Nonnull Supplier&lt;T&gt; supplier;
            private final long from;
            private final long to;

<span class="fc" id="L211">            private WeightNode(@Nonnull Supplier&lt;T&gt; supplier, long from, long to) {</span>
<span class="fc" id="L212">                this.supplier = supplier;</span>
<span class="fc" id="L213">                this.from = from;</span>
<span class="fc" id="L214">                this.to = to;</span>
<span class="fc" id="L215">            }</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>