<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Rng.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.base.random</a> &gt; <span class="el_source">Rng.java</span></div><h1>Rng.java</h1><pre class="source lang-java linenums">package space.sunqian.common.base.random;

import space.sunqian.annotations.Nonnull;
import space.sunqian.common.Check;

import java.nio.ByteBuffer;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.DoubleSupplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;

/**
 * The Random Number Generator, base interface to produce random numbers. It extends the {@link IntSupplier},
 * {@link LongSupplier} and {@link DoubleSupplier}, to supply random {@code int}, {@code long} and {@code double}
 * values.
 *
 * @author sunqian
 */
public interface Rng extends IntSupplier, LongSupplier, DoubleSupplier {

    /**
     * Returns a {@link Rng} instance.
     *
     * @return a {@link Rng} instance
     */
    static @Nonnull Rng newRng() {
<span class="fc" id="L33">        Random random = new Random();</span>
        // random.setSeed(System.nanoTime());
<span class="fc" id="L35">        return newRng(random);</span>
    }

    /**
     * Returns a {@link Rng} instance with the specified seed.
     *
     * @param seed the specified seed
     * @return a {@link Rng} instance with the specified seed
     */
    static @Nonnull Rng newRng(long seed) {
<span class="fc" id="L45">        Random random = new Random(seed);</span>
        // random.setSeed(seed);
<span class="fc" id="L47">        return newRng(random);</span>
    }

    /**
     * Returns a {@link Rng} instance based on the specified {@link Random}.
     *
     * @param random the specified {@link Random}
     * @return a {@link Rng} instance based on the specified {@link Random}
     */
    static @Nonnull Rng newRng(@Nonnull Random random) {
<span class="fc" id="L57">        return RngService.INST.random(random);</span>
    }

    /**
     * Returns a {@link Rng} instance based on the {@link ThreadLocalRandom}, and it is thread-safe and its
     * {@link #reset(long)} has no effect.
     *
     * @return a {@link Rng} instance based on the {@link ThreadLocalRandom}
     */
    static @Nonnull Rng threadLocal() {
<span class="fc" id="L67">        return RngService.INST.threadLocalRandom();</span>
    }

    /**
     * Returns a {@link Rng} instance based on the {@link SecureRandom} with the specified random algorithm. This method
     * is equivalent to:
     * &lt;pre&gt;{@code
     * try {
     *     SecureRandom secureRandom = SecureRandom.getInstance(algorithm);
     *     return Rng.newRng(secureRandom);
     * } catch (NoSuchAlgorithmException e) {
     *     throw new UnsupportedOperationException(e);
     * }
     * }&lt;/pre&gt;
     *
     * @param algorithm the specified random algorithm
     * @return a {@link Rng} instance based on the {@link SecureRandom} with the specified random algorithm
     * @throws UnsupportedOperationException if the specified algorithm is unsupported
     * @see SecureRandom#getInstance(String)
     */
    static @Nonnull Rng secure(@Nonnull String algorithm) throws UnsupportedOperationException {
        try {
<span class="fc" id="L89">            SecureRandom secureRandom = SecureRandom.getInstance(algorithm);</span>
<span class="fc" id="L90">            return newRng(secureRandom);</span>
<span class="fc" id="L91">        } catch (NoSuchAlgorithmException e) {</span>
<span class="fc" id="L92">            throw new UnsupportedOperationException(e);</span>
        }
    }

    /**
     * Resets a random seed for this {@link Rng}.
     */
    default void reset() {
<span class="fc" id="L100">        reset(nextLong());</span>
<span class="fc" id="L101">    }</span>

    /**
     * Resets this {@link Rng} via the specified seed.
     *
     * @param seed the specified seed
     */
    void reset(long seed);

    /**
     * Resets this {@link Rng} via the specified seed.
     *
     * @param seed the specified seed
     */
    void reset(byte @Nonnull [] seed);

    /**
     * Returns the next random boolean value.
     *
     * @return the next random boolean value
     */
    default boolean nextBoolean() {
<span class="fc bfc" id="L123" title="All 2 branches covered.">        return nextInt() &lt; 0;</span>
    }

    /**
     * Returns the next random int value.
     *
     * @return the next random int value
     */
    int nextInt();

    /**
     * Returns the next random int value in the range {@code [startInclusive, endExclusive)}. If
     * {@code startInclusive == endExclusive}, then {@code startInclusive} is returned.
     * &lt;p&gt;
     * Note that if this method needs to be invoked multiple times, it is recommended to use {@code ints} or
     * {@code intSupplier} to reduce overhead.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return the next random int value in the range {@code [startInclusive, endExclusive)}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    int nextInt(int startInclusive, int endExclusive) throws IllegalArgumentException;

    /**
     * Returns the next random long value.
     *
     * @return the next random long value
     */
    long nextLong();

    /**
     * Returns the next random long value in the range {@code [startInclusive, endExclusive)}. If
     * {@code startInclusive == endExclusive}, then {@code startInclusive} is returned.
     * &lt;p&gt;
     * Note that if this method needs to be invoked multiple times, it is recommended to use {@code longs} or
     * {@code longSupplier} to reduce overhead.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return the next random long value in the range {@code [startInclusive, endExclusive)}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    long nextLong(long startInclusive, long endExclusive) throws IllegalArgumentException;

    /**
     * Returns the next random float value in the range {@code [0.0, 1.0)}.
     *
     * @return the next random float value in the range {@code [0.0, 1.0)}
     */
    float nextFloat();

    /**
     * Returns the next random float value in the range {@code [startInclusive, endExclusive)}. If
     * {@code startInclusive == endExclusive}, then {@code startInclusive} is returned.
     * &lt;p&gt;
     * Note that if this method needs to be invoked multiple times, it is recommended to use {@code doubles} or
     * {@code doubleSupplier} to reduce overhead.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return the next random float value in the range {@code [startInclusive, endExclusive)}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    float nextFloat(float startInclusive, float endExclusive) throws IllegalArgumentException;

    /**
     * Returns the next random double value in the range {@code [0.0, 1.0)}.
     *
     * @return the next random double value in the range {@code [0.0, 1.0)}
     */
    double nextDouble();

    /**
     * Returns the next random double value in the range {@code [startInclusive, endExclusive)}. If
     * {@code startInclusive == endExclusive}, then {@code startInclusive} is returned.
     * &lt;p&gt;
     * Note that if this method needs to be invoked multiple times, it is recommended to use {@code doubles} or
     * {@code doubleSupplier} to reduce overhead.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return the next random double value in the range {@code [startInclusive, endExclusive)}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    double nextDouble(double startInclusive, double endExclusive) throws IllegalArgumentException;

    /**
     * Returns a new random byte array of the specified length.
     *
     * @param length the specified length of the array
     * @return a new random byte array of the specified length
     * @throws NegativeArraySizeException if {@code length &lt; 0}
     */
    default byte @Nonnull [] nextBytes(int length) throws NegativeArraySizeException {
<span class="fc" id="L218">        byte[] bytes = new byte[length];</span>
<span class="fc" id="L219">        nextBytes(bytes, 0, length);</span>
<span class="fc" id="L220">        return bytes;</span>
    }

    /**
     * Fills the specified byte array with random bytes.
     *
     * @param bytes the specified byte array
     */
    default void nextBytes(byte @Nonnull [] bytes) {
<span class="fc" id="L229">        nextBytes(bytes, 0, bytes.length);</span>
<span class="fc" id="L230">    }</span>

    /**
     * Fills the specified byte array with {@code len} random bytes, starting at the specified offset.
     *
     * @param bytes the specified byte array
     * @param off   the specified offset
     * @param len   the number of bytes to fill
     * @throws IndexOutOfBoundsException if {@code off &lt; 0} or {@code len &lt; 0} or {@code off + len &gt; bytes.length}
     */
    default void nextBytes(byte @Nonnull [] bytes, int off, int len) throws IndexOutOfBoundsException {
<span class="fc" id="L241">        Check.checkOffLen(off, len, bytes.length);</span>
<span class="fc" id="L242">        int i = off;</span>
<span class="fc" id="L243">        int end = off + len;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (int words = len &gt;&gt; 3; words-- &gt; 0; ) {</span>
<span class="fc" id="L245">            long rnd = nextLong();</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">            for (int n = 8; n-- &gt; 0; rnd &gt;&gt;&gt;= Byte.SIZE) {</span>
<span class="fc" id="L247">                bytes[i++] = (byte) rnd;</span>
            }
<span class="fc" id="L249">        }</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (i &lt; end) {</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            for (long rnd = nextLong(); i &lt; end; rnd &gt;&gt;&gt;= Byte.SIZE) {</span>
<span class="fc" id="L252">                bytes[i++] = (byte) rnd;</span>
            }
        }
<span class="fc" id="L255">    }</span>

    /**
     * Fills the specified byte buffer with random bytes. The buffer's position increments by the actual filled number.
     *
     * @param bytes the specified byte buffer
     */
    default void nextBytes(@Nonnull ByteBuffer bytes) {
<span class="fc" id="L263">        int remaining = bytes.remaining();</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (bytes.hasArray()) {</span>
<span class="fc" id="L265">            nextBytes(bytes.array(), bytes.arrayOffset() + bytes.position(), remaining);</span>
<span class="fc" id="L266">            bytes.position(bytes.position() + remaining);</span>
        } else {
<span class="fc" id="L268">            byte[] rd = new byte[remaining];</span>
<span class="fc" id="L269">            nextBytes(rd);</span>
<span class="fc" id="L270">            bytes.put(rd);</span>
        }
<span class="fc" id="L272">    }</span>

    /**
     * Returns a new unlimited {@link IntStream} that produces random int values.
     *
     * @return a new unlimited {@link IntStream} that produces random int values
     */
    default @Nonnull IntStream ints() {
<span class="fc" id="L280">        return IntStream.generate(this::nextInt);</span>
    }

    /**
     * Returns a new unlimited {@link IntStream} that produces random int values in the range
     * {@code [startInclusive, endExclusive)}. If {@code startInclusive == endExclusive}, then {@code startInclusive} is
     * always produced.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new unlimited {@link IntStream} that produces random int values in the range
     * {@code [startInclusive, endExclusive)}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    default @Nonnull IntStream ints(int startInclusive, int endExclusive) throws IllegalArgumentException {
<span class="fc" id="L295">        IntSupplier supplier = intSupplier(startInclusive, endExclusive);</span>
<span class="fc" id="L296">        return IntStream.generate(supplier);</span>
    }

    /**
     * Returns a new {@link IntStream} that produces random int values, and the stream size is limited by the given
     * size.
     *
     * @param size the given stream size
     * @return a new {@link IntStream} that produces random int values, and the stream size is limited by the given size
     * @throws IllegalArgumentException if {@code size &lt; 0}
     */
    default @Nonnull IntStream ints(long size) throws IllegalArgumentException {
<span class="fc" id="L308">        return ints().limit(size);</span>
    }

    /**
     * Returns a new {@link IntStream} that produces random int values in the range
     * {@code [startInclusive, endExclusive)}, and the stream size is limited by the given size. If
     * {@code startInclusive == endExclusive}, then {@code startInclusive} is always produced.
     *
     * @param size           the given stream size
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new {@link IntStream} that produces random int values in the range
     * {@code [startInclusive, endExclusive)}, and the stream size is limited by the given size
     * @throws IllegalArgumentException if {@code size &lt; 0} or {@code startInclusive &gt; endExclusive}
     */
    default @Nonnull IntStream ints(long size, int startInclusive, int endExclusive) throws IllegalArgumentException {
<span class="fc" id="L324">        return ints(startInclusive, endExclusive).limit(size);</span>
    }

    /**
     * Returns a new {@link IntSupplier} that produces random int values.
     *
     * @return a new {@link IntSupplier} that produces random int values
     */
    default @Nonnull IntSupplier intSupplier() {
<span class="fc" id="L333">        return this::nextInt;</span>
    }

    /**
     * Returns a new {@link IntSupplier} that produces random {@code int} value in the range:
     * {@code startInclusive &lt;= value &lt; endExclusive}. If {@code startInclusive == endExclusive}, then
     * {@code startInclusive} is always produced.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new {@link IntSupplier} that produces random {@code int} value in the range:
     * {@code startInclusive &lt;= value &lt; endExclusive}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    @Nonnull
    IntSupplier intSupplier(int startInclusive, int endExclusive) throws IllegalArgumentException;

    /**
     * Returns a new unlimited {@link LongStream} that produces random long values.
     *
     * @return a new unlimited {@link LongStream} that produces random long values
     */
    default @Nonnull LongStream longs() {
<span class="fc" id="L356">        return LongStream.generate(this::nextLong);</span>
    }

    /**
     * Returns a new unlimited {@link LongStream} that produces random long values in the range
     * {@code [startInclusive, endExclusive)}. If {@code startInclusive == endExclusive}, then {@code startInclusive} is
     * always produced.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new unlimited {@link LongStream} that produces random long values in the range
     * {@code [startInclusive, endExclusive)}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    default @Nonnull LongStream longs(long startInclusive, long endExclusive) throws IllegalArgumentException {
<span class="fc" id="L371">        LongSupplier supplier = longSupplier(startInclusive, endExclusive);</span>
<span class="fc" id="L372">        return LongStream.generate(supplier);</span>
    }

    /**
     * Returns a new {@link LongStream} that produces random long values, and the stream size is limited by the given
     * size.
     *
     * @param size the given stream size
     * @return a new {@link LongStream} that produces random long values, and the stream size is limited by the given
     * size
     * @throws IllegalArgumentException if {@code size &lt; 0}
     */
    default @Nonnull LongStream longs(long size) throws IllegalArgumentException {
<span class="fc" id="L385">        return longs().limit(size);</span>
    }

    /**
     * Returns a new {@link LongStream} that produces random long values in the range
     * {@code [startInclusive, endExclusive)}, and the stream size is limited by the given size. If
     * {@code startInclusive == endExclusive}, then {@code startInclusive} is always produced.
     *
     * @param size           the given stream size
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new {@link LongStream} that produces random long values in the range
     * {@code [startInclusive, endExclusive)}, and the stream size is limited by the given size
     * @throws IllegalArgumentException if {@code size &lt; 0} or {@code startInclusive &gt; endExclusive}
     */
    default @Nonnull LongStream longs(long size, long startInclusive, long endExclusive) throws IllegalArgumentException {
<span class="fc" id="L401">        return longs(startInclusive, endExclusive).limit(size);</span>
    }

    /**
     * Returns a new {@link LongSupplier} that produces random long values.
     *
     * @return a new {@link LongSupplier} that produces random long values
     */
    default @Nonnull LongSupplier longSupplier() {
<span class="fc" id="L410">        return this::nextLong;</span>
    }

    /**
     * Returns a new {@link LongSupplier} that produces random {@code long} value in the range:
     * {@code startInclusive &lt;= value &lt; endExclusive}. If {@code startInclusive == endExclusive}, then
     * {@code startInclusive} is always produced.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new {@link LongSupplier} that produces random {@code long} value in the range:
     * {@code startInclusive &lt;= value &lt; endExclusive}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    LongSupplier longSupplier(long startInclusive, long endExclusive) throws IllegalArgumentException;

    /**
     * Returns a new unlimited {@link DoubleStream} that produces random double values in the range {@code [0.0, 1.0)}.
     *
     * @return a new unlimited {@link DoubleStream} that produces random double values in the range {@code [0.0, 1.0)}
     */
    default @Nonnull DoubleStream doubles() {
<span class="fc" id="L432">        return DoubleStream.generate(this::nextDouble);</span>
    }

    /**
     * Returns a new unlimited {@link DoubleStream} that produces random double values in the range
     * {@code [startInclusive, endExclusive)}. If {@code startInclusive == endExclusive}, then {@code startInclusive} is
     * always produced.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new unlimited {@link DoubleStream} that produces random double values in the range
     * {@code [startInclusive, endExclusive)}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    default @Nonnull DoubleStream doubles(double startInclusive, double endExclusive) throws IllegalArgumentException {
<span class="fc" id="L447">        DoubleSupplier supplier = doubleSupplier(startInclusive, endExclusive);</span>
<span class="fc" id="L448">        return DoubleStream.generate(supplier);</span>
    }

    /**
     * Returns a new {@link DoubleStream} that produces random double values in the range {@code [0.0, 1.0)}, and the
     * stream size is limited by the given size.
     *
     * @param size the given stream size
     * @return a new {@link DoubleStream} that produces random double values in the range {@code [0.0, 1.0)}, and the
     * stream size is limited by the given size
     * @throws IllegalArgumentException if {@code size &lt; 0}
     */
    default @Nonnull DoubleStream doubles(long size) throws IllegalArgumentException {
<span class="fc" id="L461">        return doubles().limit(size);</span>
    }

    /**
     * Returns a new {@link DoubleStream} that produces random double values in the range
     * {@code [startInclusive, endExclusive)}, and the stream size is limited by the given size. If
     * {@code startInclusive == endExclusive}, then {@code startInclusive} is always produced.
     *
     * @param size           the given stream size
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new {@link DoubleStream} that produces random double values in the range
     * {@code [startInclusive, endExclusive)}, and the stream size is limited by the given size
     * @throws IllegalArgumentException if {@code size &lt; 0} or {@code startInclusive &gt; endExclusive}
     */
    default @Nonnull DoubleStream doubles(long size, double startInclusive, double endExclusive) throws IllegalArgumentException {
<span class="fc" id="L477">        return doubles(startInclusive, endExclusive).limit(size);</span>
    }

    /**
     * Returns a new {@link DoubleSupplier} that produces random double values in the range {@code [0.0, 1.0)}.
     *
     * @return a new {@link DoubleSupplier} that produces random double values in the range {@code [0.0, 1.0)}
     */
    default @Nonnull DoubleSupplier doubleSupplier() {
<span class="fc" id="L486">        return this::nextDouble;</span>
    }

    /**
     * Returns a new {@link DoubleSupplier} that produces random {@code double} value in the range:
     * {@code startInclusive &lt;= value &lt; endExclusive}. If {@code startInclusive == endExclusive}, then
     * {@code startInclusive} is always produced.
     *
     * @param startInclusive the start value inclusive
     * @param endExclusive   the end value exclusive
     * @return a new {@link DoubleSupplier} that produces random {@code double} value in the range:
     * {@code startInclusive &lt;= value &lt; endExclusive}
     * @throws IllegalArgumentException if {@code startInclusive &gt; endExclusive}
     */
    @Nonnull
    DoubleSupplier doubleSupplier(double startInclusive, double endExclusive) throws IllegalArgumentException;

    /**
     * Returns the next random int value.
     *
     * @return the next random int value
     */
    @Override
    default int getAsInt() {
<span class="fc" id="L510">        return nextInt();</span>
    }

    /**
     * Returns the next random long value.
     *
     * @return the next random long value
     */
    @Override
    default long getAsLong() {
<span class="fc" id="L520">        return nextLong();</span>
    }

    /**
     * Returns the next random double value in the range {@code [0.0, 1.0)}.
     *
     * @return the next random double value in the range {@code [0.0, 1.0)}
     */
    @Override
    default double getAsDouble() {
<span class="fc" id="L530">        return nextDouble();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>