<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NameFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.base.string</a> &gt; <span class="el_source">NameFormatter.java</span></div><h1>NameFormatter.java</h1><pre class="source lang-java linenums">package space.sunqian.common.base.string;

import space.sunqian.annotations.Nonnull;
import space.sunqian.common.base.value.Span;

import java.util.Objects;

/**
 * Name formatter, used to parse or format a given name. A name formatter represents a formatting scheme, such as
 * {@code Camel Case}, {@code Snake Case}, {@code File Naming}, etc.
 *
 * @author sunqian
 */
public interface NameFormatter {

    /**
     * Returns a new {@link NameFormatter} for lower camel case (e.g. {@code someName}). The returned instance applies
     * the lower camel case to parse letters in {@code a-z} and {@code A-Z}, but treats digits ({@code 0-9}) and other
     * characters as separate words.
     *
     * @return a new {@link NameFormatter} for lower camel case (e.g. {@code someName})
     */
    static @Nonnull NameFormatter lowerCamel() {
<span class="fc" id="L24">        return NameFormatterBack.camelCase(false);</span>
    }

    /**
     * Returns a new {@link NameFormatter} for upper camel case (e.g. {@code SomeName}), also called pascal case. The
     * returned instance applies the upper camel case to parse letters in {@code a-z} and {@code A-Z}, but treats digits
     * ({@code 0-9}) and other characters as separate words.
     *
     * @return a new {@link NameFormatter} for upper camel case (e.g. {@code SomeName})
     */
    static @Nonnull NameFormatter upperCamel() {
<span class="fc" id="L35">        return NameFormatterBack.camelCase(true);</span>
    }

    /**
     * Returns a new {@link NameFormatter} base on the specified delimiter (e.g. {@code some-name}, {@code some_name}).
     *
     * @param delimiter the specified delimiter
     * @return a new {@link NameFormatter} base on the specified delimiter (e.g. {@code some-name}, {@code some_name})
     * @throws IllegalArgumentException if the delimiter is empty
     */
    static @Nonnull NameFormatter delimiterCase(
        @Nonnull CharSequence delimiter
    ) throws IllegalArgumentException {
<span class="fc" id="L48">        return delimiterCase(delimiter, simpleAppender());</span>
    }

    /**
     * Returns a new {@link NameFormatter} base on the specified delimiter (e.g. {@code some-name}, {@code some_name}).
     *
     * @param delimiter the specified delimiter, can not be empty
     * @param appender  the appender used to append each word into the destination appendable object
     * @return a new {@link NameFormatter} base on the specified delimiter (e.g. {@code some-name}, {@code some_name})
     * @throws IllegalArgumentException if the delimiter is empty
     */
    static @Nonnull NameFormatter delimiterCase(
        @Nonnull CharSequence delimiter, @Nonnull NameFormatter.Appender appender
    ) throws IllegalArgumentException {
<span class="fc" id="L62">        return NameFormatterBack.delimiterCase(delimiter, appender);</span>
    }

    /**
     * Returns a new {@link NameFormatter} used to separate file base name and file extension (e.g.
     * {@code some-name.txt} split to {@code some-name} and {@code txt}).
     *
     * @return a new {@link NameFormatter} used to separate file base name and file extension (e.g.
     * {@code some-name.txt} split to {@code some-name} and {@code txt})
     */
    static @Nonnull NameFormatter fileNaming() {
<span class="fc" id="L73">        return NameFormatterBack.fileNaming();</span>
    }

    /**
     * Returns an instance of {@link NameFormatter.Appender} which simply adds the word without any modifications.
     *
     * @return an instance of {@link NameFormatter.Appender} which simply adds the word without any modifications
     */
    static @Nonnull NameFormatter.Appender simpleAppender() {
<span class="fc" id="L82">        return NameFormatterBack.simpleAppender();</span>
    }

    /**
     * Parses the given name, splits it into an array of words by scheme of this formatter.
     *
     * @param name the given name
     * @return an array of words split from the given name
     * @throws NameFormatException if failed to parse the given name
     */
    default @Nonnull String @Nonnull [] parse(@Nonnull CharSequence name) throws NameFormatException {
<span class="fc" id="L93">        Span[] spans = tokenize(name);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (spans.length &lt;= 1) {</span>
<span class="fc" id="L95">            return new String[]{name.toString()};</span>
        }
<span class="fc" id="L97">        String[] ret = new String[spans.length];</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        for (int i = 0; i &lt; spans.length; i++) {</span>
<span class="fc" id="L99">            ret[i] = name.subSequence(spans[i].startIndex(), spans[i].endIndex()).toString();</span>
        }
<span class="fc" id="L101">        return ret;</span>
    }

    /**
     * Parses the given name, splits it into an array of words by scheme of this formatter. Returns an array of
     * {@link Span}s define the range of each word within the given name.
     *
     * @param name the given name
     * @return an array of {@link Span}s define the range of each word within the given name
     * @throws NameFormatException if failed to parse the given name
     */
    @Nonnull
    Span @Nonnull [] tokenize(@Nonnull CharSequence name) throws NameFormatException;

    /**
     * Joins the given words into a name by rules of this name formatter.
     *
     * @param words the given words
     * @return a name joined by the given words by rules of this name formatter
     * @throws NameFormatException if failed to join the words
     */
    default @Nonnull String format(@Nonnull CharSequence @Nonnull ... words) throws NameFormatException {
<span class="fc" id="L123">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L124">        format(words, sb);</span>
<span class="fc" id="L125">        return sb.toString();</span>
    }

    /**
     * Joins the given words into a name by rules of this name formatter. The joined name will be appended to the
     * specified destination appendable.
     *
     * @param words the given words
     * @param dst   the specified destination appendable
     * @throws NameFormatException if failed to join the words
     */
    void format(
        @Nonnull CharSequence @Nonnull [] words,
        @Nonnull Appendable dst
    ) throws NameFormatException;

    /**
     * Joins the words into a name by rules of this name formatter. The words are specified by the array of {@link Span}
     * that define the range of each word within the given original name.
     *
     * @param originalName the given original name where the word spans are derived
     * @param wordSpans    the array of {@link Span} that define the range of each word within the given original name
     * @return a name joined from the words by rules of this name formatter
     * @throws NameFormatException if failed to join the words
     */
    default @Nonnull String format(
        @Nonnull CharSequence originalName, @Nonnull Span @Nonnull [] wordSpans
    ) throws NameFormatException {
<span class="fc" id="L153">        StringBuilder sb = new StringBuilder(originalName.length());</span>
<span class="fc" id="L154">        format(originalName, wordSpans, sb);</span>
<span class="fc" id="L155">        return sb.toString();</span>
    }

    /**
     * Joins the words into a name by rules of this name formatter. The words are specified by the array of {@link Span}
     * that define the range of each word within the given original name. The joined name will be appended to the
     * specified destination appendable.
     *
     * @param originalName the given original name where the word spans are derived
     * @param wordSpans    the array of {@link Span} that define the range of each word within the given original name
     * @param dst          the specified destination appendable
     * @throws NameFormatException if failed to join the words
     */
    void format(
        @Nonnull CharSequence originalName,
        @Nonnull Span @Nonnull [] wordSpans,
        @Nonnull Appendable dst
    ) throws NameFormatException;

    /**
     * Converts the given name from this name formatter to the other specified name formatter. This method is equivalent
     * to: {@code otherFormatter.format(name, tokenize(name))}.
     *
     * @param name           the given name
     * @param otherFormatter the other specified name formatter
     * @return the converted name
     * @throws NameFormatException if the conversion is not supported for the given name
     */
    default @Nonnull String format(
        @Nonnull CharSequence name, @Nonnull NameFormatter otherFormatter
    ) throws NameFormatException {
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (Objects.equals(this, otherFormatter)) {</span>
<span class="fc" id="L187">            return name.toString();</span>
        }
<span class="fc" id="L189">        return otherFormatter.format(name, tokenize(name));</span>
    }

    /**
     * Appender for appending each word split by {@link #tokenize(CharSequence)} into the specified {@link Appendable}.
     */
    interface Appender {

        /**
         * Appends the word into the specified {@link Appendable}, the word is specified by the given span that define
         * the range of the word within the given original name.
         *
         * @param dst          the specified {@link Appendable}
         * @param originalName the given original name where the word span is derived
         * @param span         the span that define the range of the word within the given original name
         * @param index        the index of the word in the returned list of {@link #tokenize(CharSequence)}
         * @throws Exception if failed to append
         */
        void append(
            @Nonnull Appendable dst,
            @Nonnull CharSequence originalName,
            @Nonnull Span span,
            int index
        ) throws Exception;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>