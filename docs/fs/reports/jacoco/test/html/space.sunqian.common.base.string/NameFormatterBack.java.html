<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NameFormatterBack.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fs-all</a> &gt; <a href="index.source.html" class="el_package">space.sunqian.common.base.string</a> &gt; <span class="el_source">NameFormatterBack.java</span></div><h1>NameFormatterBack.java</h1><pre class="source lang-java linenums">package space.sunqian.common.base.string;

import space.sunqian.annotations.Nonnull;
import space.sunqian.common.Check;
import space.sunqian.common.base.value.Span;
import space.sunqian.common.collect.ArrayKit;

final class NameFormatterBack {

    static @Nonnull NameFormatter camelCase(boolean upperFirst) {
<span class="fc" id="L11">        return new CamelCase(upperFirst);</span>
    }

    static @Nonnull NameFormatter delimiterCase(
        @Nonnull CharSequence delimiter, @Nonnull NameFormatter.Appender appender
    ) throws IllegalArgumentException {
<span class="fc" id="L17">        return new DelimiterCase(delimiter, appender);</span>
    }

    static @Nonnull NameFormatter fileNaming() {
<span class="fc" id="L21">        return new FileNaming();</span>
    }

    static @Nonnull NameFormatter.Appender simpleAppender() {
<span class="fc" id="L25">        return SimpleAppender.INST;</span>
    }

    private static final class CamelCase implements NameFormatter {

        private static final int LOWER = 1;
        private static final int UPPER = 2;
        private static final int NUM = 4;
        private static final int OTHER = 8;

        private final boolean upperFirst;

<span class="fc" id="L37">        private CamelCase(boolean upperFirst) {</span>
<span class="fc" id="L38">            this.upperFirst = upperFirst;</span>
<span class="fc" id="L39">        }</span>

        @Override
        public @Nonnull Span @Nonnull [] tokenize(@Nonnull CharSequence name) {
<span class="fc" id="L43">            int len = name.length();</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L45">                return new Span[]{Span.empty()};</span>
            }
<span class="fc bfc" id="L47" title="All 2 branches covered.">            if (len == 1) {</span>
<span class="fc" id="L48">                return new Span[]{Span.of(0, 1)};</span>
            }
<span class="fc" id="L50">            int size = 1;</span>
<span class="fc" id="L51">            int start = 0;</span>
<span class="fc" id="L52">            int i = 1;</span>
<span class="fc" id="L53">            int t1 = charType(name.charAt(0));</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">            while (i &lt; name.length()) {</span>
<span class="fc" id="L55">                int t2 = charType(name.charAt(i));</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">                if (t1 == t2) {</span>
<span class="fc" id="L57">                    i++;</span>
<span class="fc" id="L58">                    continue;</span>
                }
                // Aa: check AAa and aAa
<span class="fc bfc" id="L61" title="All 4 branches covered.">                if (t1 == UPPER &amp;&amp; t2 == LOWER) {</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">                    if (start == i - 1) {</span>
                        // Aa: one word
<span class="fc" id="L64">                        i++;</span>
<span class="fc" id="L65">                        t1 = t2;</span>
<span class="fc" id="L66">                        continue;</span>
                    } else {
                        // AAa: split as A + Aa
<span class="fc" id="L69">                        start = i - 1;</span>
                    }
                } else {
                    // others start from current char
<span class="fc" id="L73">                    start = i;</span>
                }
                // others add one word
<span class="fc" id="L76">                size++;</span>
<span class="fc" id="L77">                i++;</span>
<span class="fc" id="L78">                t1 = t2;</span>
<span class="fc" id="L79">            }</span>
<span class="fc" id="L80">            Span[] spans = new Span[size];</span>
<span class="fc" id="L81">            start = 0;</span>
<span class="fc" id="L82">            i = 1;</span>
<span class="fc" id="L83">            int wi = 0;</span>
<span class="fc" id="L84">            t1 = charType(name.charAt(0));</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">            while (i &lt; name.length()) {</span>
<span class="fc" id="L86">                int t2 = charType(name.charAt(i));</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">                if (t1 == t2) {</span>
<span class="fc" id="L88">                    i++;</span>
<span class="fc" id="L89">                    continue;</span>
                }
                // Aa: check AAa and aAa
<span class="fc bfc" id="L92" title="All 4 branches covered.">                if (t1 == UPPER &amp;&amp; t2 == LOWER) {</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">                    if (start == i - 1) {</span>
                        // Aa: one word
<span class="fc" id="L95">                        i++;</span>
<span class="fc" id="L96">                        t1 = t2;</span>
<span class="fc" id="L97">                        continue;</span>
                    } else {
                        // AAa: split as A + Aa
<span class="fc" id="L100">                        spans[wi++] = Span.of(start, i - 1);</span>
<span class="fc" id="L101">                        start = i - 1;</span>
                    }
                } else {
                    // others start from current char
<span class="fc" id="L105">                    spans[wi++] = Span.of(start, i);</span>
<span class="fc" id="L106">                    start = i;</span>
                }
<span class="fc" id="L108">                i++;</span>
<span class="fc" id="L109">                t1 = t2;</span>
<span class="fc" id="L110">            }</span>
<span class="fc" id="L111">            spans[wi] = Span.of(start, name.length());</span>
<span class="fc" id="L112">            return spans;</span>
        }

        @Override
        public void format(
            @Nonnull CharSequence @Nonnull [] words, @Nonnull Appendable dst
        ) throws NameFormatException {
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (words.length == 0) {</span>
<span class="fc" id="L120">                return;</span>
            }
            try {
<span class="fc" id="L123">                format0(words, dst);</span>
<span class="fc" id="L124">            } catch (Exception e) {</span>
<span class="fc" id="L125">                throw new NameFormatException(e);</span>
<span class="fc" id="L126">            }</span>
<span class="fc" id="L127">        }</span>

        private void format0(
            @Nonnull CharSequence @Nonnull [] words, @Nonnull Appendable dst
        ) throws Exception {
<span class="fc" id="L132">            CharSequence first = words[0];</span>
<span class="fc" id="L133">            appendFirstWord(dst, first, Span.of(0, first.length()));</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            if (words.length &gt; 1) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">                for (int i = 1; i &lt; words.length; i++) {</span>
<span class="fc" id="L136">                    appendWord(dst, words[i], Span.of(0, words[i].length()));</span>
                }
            }
<span class="fc" id="L139">        }</span>

        @Override
        public void format(
            @Nonnull CharSequence originalName,
            @Nonnull Span @Nonnull [] wordSpans,
            @Nonnull Appendable dst
        ) throws NameFormatException {
<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (wordSpans.length == 0) {</span>
<span class="fc" id="L148">                return;</span>
            }
            try {
<span class="fc" id="L151">                format0(originalName, wordSpans, dst);</span>
<span class="fc" id="L152">            } catch (Exception e) {</span>
<span class="fc" id="L153">                throw new NameFormatException(e);</span>
<span class="fc" id="L154">            }</span>
<span class="fc" id="L155">        }</span>

        private void format0(
            @Nonnull CharSequence originalName,
            @Nonnull Span @Nonnull [] wordSpans,
            @Nonnull Appendable dst
        ) throws Exception {
<span class="fc" id="L162">            Span first = wordSpans[0];</span>
<span class="fc" id="L163">            appendFirstWord(dst, originalName, first);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (wordSpans.length &gt; 1) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">                for (int i = 1; i &lt; wordSpans.length; i++) {</span>
<span class="fc" id="L166">                    appendWord(dst, originalName, wordSpans[i]);</span>
                }
            }
<span class="fc" id="L169">        }</span>

        private void appendFirstWord(
            @Nonnull Appendable dst, @Nonnull CharSequence str, @Nonnull Span span
        ) throws Exception {
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (span.isEmpty()) {</span>
<span class="fc" id="L175">                return;</span>
            }
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (isAllUpper(str, span)) {</span>
<span class="fc" id="L178">                dst.append(str, span.startIndex(), span.endIndex());</span>
<span class="fc" id="L179">                return;</span>
            }
<span class="fc bfc" id="L181" title="All 2 branches covered.">            dst.append(upperFirst ?</span>
<span class="fc" id="L182">                Character.toUpperCase(str.charAt(span.startIndex()))</span>
                :
<span class="fc" id="L184">                Character.toLowerCase(str.charAt(span.startIndex()))</span>
            );
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (span.endIndex() - span.startIndex() == 1) {</span>
<span class="fc" id="L187">                return;</span>
            }
<span class="fc" id="L189">            dst.append(str, span.startIndex() + 1, span.endIndex());</span>
<span class="fc" id="L190">        }</span>

        private void appendWord(
            @Nonnull Appendable dst, @Nonnull CharSequence str, @Nonnull Span span
        ) throws Exception {
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (span.isEmpty()) {</span>
<span class="fc" id="L196">                return;</span>
            }
<span class="fc bfc" id="L198" title="All 2 branches covered.">            if (isAllUpper(str, span)) {</span>
<span class="fc" id="L199">                dst.append(str, span.startIndex(), span.endIndex());</span>
<span class="fc" id="L200">                return;</span>
            }
<span class="fc" id="L202">            dst.append(Character.toUpperCase(str.charAt(span.startIndex())));</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (span.endIndex() - span.startIndex() == 1) {</span>
<span class="fc" id="L204">                return;</span>
            }
<span class="fc" id="L206">            dst.append(str, span.startIndex() + 1, span.endIndex());</span>
<span class="fc" id="L207">        }</span>

        private boolean isAllUpper(@Nonnull CharSequence str, @Nonnull Span span) {
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (span.length() &lt; 2) {</span>
<span class="fc" id="L211">                return false;</span>
            }
<span class="fc bfc" id="L213" title="All 2 branches covered.">            return charType(str.charAt(span.startIndex())) == UPPER</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">                &amp;&amp; charType(str.charAt(span.startIndex() + 1)) == UPPER;</span>
        }

        private int charType(char c) {
<span class="fc bfc" id="L218" title="All 4 branches covered.">            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {</span>
<span class="fc" id="L219">                return LOWER;</span>
            }
<span class="fc bfc" id="L221" title="All 4 branches covered.">            if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {</span>
<span class="fc" id="L222">                return UPPER;</span>
            }
<span class="fc bfc" id="L224" title="All 4 branches covered.">            if (c &gt;= '0' &amp;&amp; c &lt;= '9') {</span>
<span class="fc" id="L225">                return NUM;</span>
            }
<span class="fc" id="L227">            return OTHER;</span>
        }
    }

    private static final class DelimiterCase implements NameFormatter {

        private final @Nonnull CharSequence delimiter;
        private final @Nonnull NameFormatter.Appender appender;

        private DelimiterCase(
            @Nonnull CharSequence delimiter, @Nonnull NameFormatter.Appender appender
<span class="fc" id="L238">        ) throws IllegalArgumentException {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            Check.checkArgument(delimiter.length() &gt; 0, &quot;The delimiter must not be empty.&quot;);</span>
<span class="fc" id="L240">            this.delimiter = delimiter;</span>
<span class="fc" id="L241">            this.appender = appender;</span>
<span class="fc" id="L242">        }</span>

        @Override
        public @Nonnull Span @Nonnull [] tokenize(@Nonnull CharSequence name) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">            if (name.length() &lt; delimiter.length()) {</span>
<span class="fc" id="L247">                return new Span[]{Span.of(0, name.length())};</span>
            }
<span class="fc" id="L249">            int size = 1;</span>
<span class="fc" id="L250">            int start = 0;</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            while (start &lt; name.length()) {</span>
<span class="fc" id="L252">                int index = StringKit.indexOf(name, delimiter, start);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                if (index &lt; 0) {</span>
<span class="fc" id="L254">                    break;</span>
                }
<span class="fc" id="L256">                size++;</span>
<span class="fc" id="L257">                start = index + delimiter.length();</span>
<span class="fc" id="L258">            }</span>
<span class="fc" id="L259">            Span[] spans = new Span[size];</span>
<span class="fc" id="L260">            int i = 0;</span>
<span class="fc" id="L261">            start = 0;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            while (start &lt; name.length()) {</span>
<span class="fc" id="L263">                int index = StringKit.indexOf(name, delimiter, start);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">                if (index &lt; 0) {</span>
<span class="fc" id="L265">                    break;</span>
                }
<span class="fc" id="L267">                spans[i++] = Span.of(start, index);</span>
<span class="fc" id="L268">                start = index + delimiter.length();</span>
<span class="fc" id="L269">            }</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">            spans[i] = start &lt; name.length() ? Span.of(start, name.length()) : Span.empty();</span>
<span class="fc" id="L271">            return spans;</span>
        }

        @Override
        public void format(
            @Nonnull CharSequence @Nonnull [] words, @Nonnull Appendable dst
        ) throws NameFormatException {
<span class="fc bfc" id="L278" title="All 2 branches covered.">            if (words.length == 0) {</span>
<span class="fc" id="L279">                return;</span>
            }
            try {
<span class="fc" id="L282">                format0(words, dst);</span>
<span class="fc" id="L283">            } catch (Exception e) {</span>
<span class="fc" id="L284">                throw new NameFormatException(e);</span>
<span class="fc" id="L285">            }</span>
<span class="fc" id="L286">        }</span>

        private void format0(
            @Nonnull CharSequence @Nonnull [] words, @Nonnull Appendable dst
        ) throws Exception {
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (words.length == 1) {</span>
<span class="fc" id="L292">                CharSequence first = words[0];</span>
<span class="fc" id="L293">                dst.append(first);</span>
<span class="fc" id="L294">                return;</span>
            }
<span class="fc" id="L296">            dst.append(words[0]);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            for (int i = 1; i &lt; words.length; i++) {</span>
<span class="fc" id="L298">                dst.append(delimiter);</span>
<span class="fc" id="L299">                dst.append(words[i]);</span>
            }
<span class="fc" id="L301">        }</span>

        @Override
        public void format(
            @Nonnull CharSequence originalName,
            @Nonnull Span @Nonnull [] wordSpans,
            @Nonnull Appendable dst
        ) throws NameFormatException {
<span class="fc bfc" id="L309" title="All 2 branches covered.">            if (wordSpans.length == 0) {</span>
<span class="fc" id="L310">                return;</span>
            }
            try {
<span class="fc" id="L313">                format0(originalName, wordSpans, dst);</span>
<span class="fc" id="L314">            } catch (Exception e) {</span>
<span class="fc" id="L315">                throw new NameFormatException(e);</span>
<span class="fc" id="L316">            }</span>
<span class="fc" id="L317">        }</span>

        private void format0(
            @Nonnull CharSequence originalName,
            @Nonnull Span @Nonnull [] wordSpans,
            @Nonnull Appendable dst
        ) throws Exception {
<span class="fc bfc" id="L324" title="All 2 branches covered.">            if (wordSpans.length == 1) {</span>
<span class="fc" id="L325">                Span first = wordSpans[0];</span>
<span class="fc" id="L326">                appender.append(dst, originalName, first, 0);</span>
<span class="fc" id="L327">                return;</span>
            }
<span class="fc" id="L329">            appender.append(dst, originalName, wordSpans[0], 0);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">            for (int i = 1; i &lt; wordSpans.length; i++) {</span>
<span class="fc" id="L331">                dst.append(delimiter);</span>
<span class="fc" id="L332">                appender.append(dst, originalName, wordSpans[i], i);</span>
            }
<span class="fc" id="L334">        }</span>
    }

    private static final class FileNaming implements NameFormatter {

<span class="fc" id="L339">        private static final SimpleAppender appender = (SimpleAppender) simpleAppender();</span>

        @Override
        public @Nonnull Span @Nonnull [] tokenize(@Nonnull CharSequence name) {
<span class="fc" id="L343">            int lastDot = StringKit.lastIndexOf(name, '.');</span>
<span class="fc bfc" id="L344" title="All 4 branches covered.">            if (lastDot &lt; 0 || lastDot == name.length() - 1) {</span>
<span class="fc" id="L345">                return new Span[]{Span.of(0, name.length())};</span>
            }
<span class="fc" id="L347">            return ArrayKit.array(</span>
<span class="fc" id="L348">                Span.of(0, lastDot),</span>
<span class="fc" id="L349">                Span.of(lastDot + 1, name.length())</span>
            );
        }

        @Override
        public void format(
            @Nonnull CharSequence @Nonnull [] words, @Nonnull Appendable dst
        ) throws NameFormatException {
<span class="fc bfc" id="L357" title="All 2 branches covered.">            if (words.length == 0) {</span>
<span class="fc" id="L358">                return;</span>
            }
            try {
<span class="fc" id="L361">                format0(words, dst);</span>
<span class="fc" id="L362">            } catch (Exception e) {</span>
<span class="fc" id="L363">                throw new NameFormatException(e);</span>
<span class="fc" id="L364">            }</span>
<span class="fc" id="L365">        }</span>

        private void format0(
            @Nonnull CharSequence @Nonnull [] words, @Nonnull Appendable dst
        ) throws Exception {
<span class="fc bfc" id="L370" title="All 2 branches covered.">            if (words.length == 1) {</span>
<span class="fc" id="L371">                CharSequence first = words[0];</span>
<span class="fc" id="L372">                dst.append(first);</span>
<span class="fc" id="L373">                return;</span>
            }
<span class="fc bfc" id="L375" title="All 2 branches covered.">            if (words.length == 2) {</span>
<span class="fc" id="L376">                CharSequence prefix = words[0];</span>
<span class="fc" id="L377">                CharSequence suffix = words[1];</span>
<span class="fc" id="L378">                dst.append(prefix);</span>
<span class="fc" id="L379">                dst.append('.');</span>
<span class="fc" id="L380">                dst.append(suffix);</span>
<span class="fc" id="L381">                return;</span>
            }
<span class="fc bfc" id="L383" title="All 2 branches covered.">            for (int i = 0; i &lt; words.length - 1; i++) {</span>
<span class="fc" id="L384">                dst.append(words[i]);</span>
            }
<span class="fc" id="L386">            dst.append('.');</span>
<span class="fc" id="L387">            CharSequence suffix = words[words.length - 1];</span>
<span class="fc" id="L388">            dst.append(suffix);</span>
<span class="fc" id="L389">        }</span>

        @Override
        public void format(
            @Nonnull CharSequence originalName,
            @Nonnull Span @Nonnull [] wordSpans,
            @Nonnull Appendable dst
        ) throws NameFormatException {
<span class="fc bfc" id="L397" title="All 2 branches covered.">            if (wordSpans.length == 0) {</span>
<span class="fc" id="L398">                return;</span>
            }
            try {
<span class="fc" id="L401">                format0(originalName, wordSpans, dst);</span>
<span class="fc" id="L402">            } catch (Exception e) {</span>
<span class="fc" id="L403">                throw new NameFormatException(e);</span>
<span class="fc" id="L404">            }</span>
<span class="fc" id="L405">        }</span>

        private void format0(
            @Nonnull CharSequence originalName,
            @Nonnull Span @Nonnull [] wordSpans,
            @Nonnull Appendable dst
        ) throws Exception {
<span class="fc bfc" id="L412" title="All 2 branches covered.">            if (wordSpans.length == 1) {</span>
<span class="fc" id="L413">                Span first = wordSpans[0];</span>
<span class="fc" id="L414">                appender.append(dst, originalName, first, 0);</span>
<span class="fc" id="L415">                return;</span>
            }
<span class="fc bfc" id="L417" title="All 2 branches covered.">            if (wordSpans.length == 2) {</span>
<span class="fc" id="L418">                Span prefix = wordSpans[0];</span>
<span class="fc" id="L419">                Span suffix = wordSpans[1];</span>
<span class="fc" id="L420">                appender.append(dst, originalName, prefix, 0);</span>
<span class="fc" id="L421">                dst.append('.');</span>
<span class="fc" id="L422">                appender.append(dst, originalName, suffix, 1);</span>
<span class="fc" id="L423">                return;</span>
            }
<span class="fc bfc" id="L425" title="All 2 branches covered.">            for (int i = 0; i &lt; wordSpans.length - 1; i++) {</span>
<span class="fc" id="L426">                appender.append(dst, originalName, wordSpans[i], i);</span>
            }
<span class="fc" id="L428">            dst.append('.');</span>
<span class="fc" id="L429">            Span suffix = wordSpans[wordSpans.length - 1];</span>
<span class="fc" id="L430">            appender.append(dst, originalName, suffix, wordSpans.length - 1);</span>
<span class="fc" id="L431">        }</span>
    }

<span class="fc" id="L434">    private enum SimpleAppender implements NameFormatter.Appender {</span>

<span class="fc" id="L436">        INST;</span>

        @Override
        public void append(
            @Nonnull Appendable dst, @Nonnull CharSequence originalName, @Nonnull Span span, int index
        ) throws Exception {
<span class="fc" id="L442">            dst.append(originalName, span.startIndex(), span.endIndex());</span>
<span class="fc" id="L443">        }</span>
    }

    private NameFormatterBack() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>